<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../../tei-P5-schemas-230717/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:tei="http://www.tei-c.org/ns/1.0"
  xml:lang="fr">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Modèle TEI pour le projet de transcription collaborative des Testaments de
          Poilus</title>
        <author>Florence Clavaud (Archives nationales | Centre Jean-Mabillon de l'Ecole nationale
          des chartes)</author>
      </titleStmt>
      <publicationStmt>
        <publisher>TEI Consortium</publisher>
        <availability status="free">
          <p>TEI material can be licensed differently depending on the use you intend to make of it.
            Hence it is made available under both the CC+BY and BSD-2 licences. The CC+BY licence is
            generally appropriate for usages which treat TEI content as data or documentation. The
            BSD-2 licence is generally appropriate for usage of TEI content in a software
            environment. For further information or clarification, please contact the TEI Consortium
            (info@tei-c.org).</p>
        </availability>
      </publicationStmt>
      <notesStmt>
        <note type="ns">http://www.example.org/ns/nonTEI</note>
      </notesStmt>
      <sourceDesc>
        <p>Written from scratch.</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <head>TEI Complete</head>
      <p>Modèle documenté pour l'encodage en TEI de l'édition de testaments de Poilus,&#13;
        telle&#13; que pourra la produire la plate-forme de transcription collaborative&#13; en&#13;
        cours de&#13; développement (projet porté par l'U. de Cergy, les Archives&#13;
        nationales,&#13; l'Ecole des&#13; chartes, les AD des Yvelines, Patrima)</p>
      <!-- <p>However, this particular TEI customization is <emph>not recommended</emph> for
                        actual use for encoding documents. It produces schemas and reference
                        documentation that will be much larger, and include many more elements, than
                        almost anyone could conceivably ever need. Tempting though it may be simply
                        to have absolutely everything, and <q>just ignore</q> elements not required,
                        experience has shown that their presence makes the documentation harder to
                        read and use, and makes a schema that is far more lax than desired.</p>-->
      <schemaSpec ident="TeiModel_for_FirstWorldWarWills" start="TEI teiCorpus" docLang="fr"
        prefix="TEI-">
        <moduleRef key="tei"/>
        <!-- required -->
        <moduleRef key="core"
          except="analytic binaryObject citedRange desc distinct divGen gb gloss headItem headLabel l lg media meeting monogr relatedItem soCalled sp speaker stage"/>
        <!-- required -->
        <moduleRef key="analysis" except="cl m phr s spanGrp w"/>
        <moduleRef key="header"/>
        <!-- required -->
        <moduleRef key="linking" except="ab alt altGrp join joinGrp timeline when"/>
        <moduleRef key="msdescription"
          except="accMat altIdentifier binding bindingDesc catchwords colophon decoDesc decoNote explicit filiation finalRubric foliation heraldry incipit layout layoutDesc locus locusGrp material msFrag msItem msItemStruct msPart musicNotation objectType origDate origPlace origin rubric scriptDesc seal sealDesc secFol signatures source stamp surrogates typeDesc typeNote watermark"/>
        <moduleRef key="namesdates"/>
        <moduleRef key="textcrit"/>
        <moduleRef key="textstructure"
          except="argument byline closer div1 div2 div3 div4 div5 div6 div7 docAuthor docDate docEdition docImprint docTitle epigraph floatingText front imprimatur opener salute titlePage titlePart trailer"/>
        <!-- required -->
        <moduleRef key="transcr"
          except="addSpan damageSpan delSpan fw handNotes handShift line listTranspose mod redo restore retrace secl sourceDoc substJoin transpose undo zone"/>
        <moduleRef key="tagdocs"/>
        <elementSpec ident="facsimile" module="transcr" mode="replace">
          <desc>Projet Testaments de Poilus : la liste des images numériques d'un testament comprend
            uniquement des éléments <gi>surface</gi>ou <gi>surfaceGrp</gi>. Pas d'attribut pour cet
            élément <gi>facsimile</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.resourceLike"/>
            <!--  <memberOf key="att.declaring"/>-->
          </classes>
          <content>
            <sequence>
              <!--   <elementRef key="front" minOccurs="0"/>-->
              <alternate minOccurs="1" maxOccurs="unbounded">
                <!--   <classRef key="model.graphicLike"/>-->
                <elementRef key="surface"/>
                <elementRef key="surfaceGrp"/>
              </alternate>
              <!--  <elementRef key="back" minOccurs="0"/>-->
            </sequence>
          </content>
          <attList>
            <attDef ident="xml:base" usage="opt">
              <desc>permettra si nécessaire de stocker une URL de base pour les images numériques,
                le segment final de l'URI de chaque image étant donné par l'attribut <att>url</att>
                de <gi>graphic</gi></desc>
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="surface" mode="replace" module="transcr">
          <gloss>surface</gloss>
          <desc type="wills-ui">Projet Testaments de Poilus : l'élément <gi>surface</gi>concerne une
            des surfaces physiques du testament (page, partie de page, recto ou verso d'une
            enveloppe). Il contient 2 éléments graphic, un pour l'image au format JPEG, l'autre pour
            l'image au format TIFF, reproduisant cette surface. Il a obligatoirement deux attributs,
              <att>type</att> et <att>n</att>.</desc>
          <classes><!-- <memberOf key="att.global"/>--><!-- <memberOf key="att.coordinated"/>
                                    <memberOf key="att.declaring"/>--><!-- <memberOf key="att.typed"/>--><!-- added by gen --></classes>
          <content>
            <!-- <sequence>
                                          -->
            <!-- <alternate minOccurs="0" maxOccurs="unbounded">
                                                <classRef key="model.global"/>
                                                <classRef key="model.labelLike"/>
                                                <classRef key="model.graphicLike"/>
                                          </alternate>
                                          -->
            <sequence minOccurs="1" maxOccurs="1">
              <!--       
                                                <alternate>
                                                      <elementRef key="zone"/>
                                                      <elementRef key="line"/>
                                                      <elementRef key="surface"/>
                                                      <elementRef key="surfaceGrp"/>
                                                </alternate>
                                                
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
              <elementRef key="graphic"/>
              <elementRef key="graphic"/>
            </sequence>
            <!--</sequence>-->
          </content>
          <attList>
            <attDef ident="n" usage="req">
              <gloss>le numéro de la surface dans l'ordre de lecture logique du testament</gloss>
            </attDef>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="will-page">
                  <gloss>page du testament</gloss>
                </valItem>
                <valItem ident="will-page-part">
                  <gloss>partie d'une page du testament</gloss>
                </valItem>
                <valItem ident="will-envelope-recto">
                  <gloss>enveloppe du testament : recto</gloss>
                </valItem>
                <valItem ident="will-envelope-verso">
                  <gloss>enveloppe du testament : verso</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><surface type="will-page" n="01"
                  ><graphic url="TIFF/FRAN_Poilus_t-0001_01.tif" xml:id="testament-0001_vue-01_jpg"
                  /><graphic url="JPEG/FRAN_Poilus_t-0001_01.jpg" xml:id="testament-0001_vue-01_tif"
                /></surface></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><surfaceGrp type="will-page" n="02"
                  ><surface type="will-page-part" n="02a"><graphic
                    url="JPEG/FRAN_Poilus_t-0001_02a.jpg" xml:id="testament-0001_vue-02a_jpg"
                    > </graphic><graphic url="TIFF/FRAN_Poilus_t-0001_02a.tif"
                    xml:id="testament-0001_vue-02a_tif"/></surface><surface type="will-page-part"
                  n="02b"><graphic url="JPEG/FRAN_Poilus_t-0001_02b.jpg"
                    xml:id="testament-0001_vue-02b_jpg"/><graphic
                    url="TIFF/FRAN_Poilus_t-0001_02b.jpg" xml:id="testament-0001_vue-02b_tif"
                  /></surface></surfaceGrp></egXML>
          </exemplum>
        </elementSpec>
        <elementSpec ident="surfaceGrp" module="transcr" mode="replace">
          <desc type="wills-ui">Projet Testaments de Poilus : <gi>surfaceGrp</gi> est utilisé
            lorsque la page du testament dont il sert à déclarer les reproductions numériques est en
            fait physiquement segmentée en deux parties du fait que le testament est cousu avec les
            autres pièces formant la minute notariale. On peut donc avoir dans ce cas deux (ou plus
            ?) surfaces différentes constituant, regroupées, une page. Ces deux surfaces sont
            numérisées isolément. Donc l'élément <gi>surfaceGrp</gi> contient au moins 2 éléments
              <gi>surface</gi>. L'élément <gi>surfaceGrp</gi> porte obligatoirement un attribut
              <att>type</att> et un attribut <att>n</att>.</desc>
          <classes><!--<memberOf key="att.global"/>--><!--    <memberOf key="att.coordinated"/> --><!--  <memberOf key="att.declaring"/>--><!-- <memberOf key="att.typed"/>--><!-- added by gen --></classes>
          <content>
            <!--   <alternate minOccurs="1" maxOccurs="unbounded">
                                          <classRef key="model.global"/>
                                          <elementRef key="surface"/>
                                          <elementRef key="surfaceGrp"/>
                                    </alternate>-->
            <sequence minOccurs="1" maxOccurs="unbounded">
              <!--       
                                                <alternate>
                                                      <elementRef key="zone"/>
                                                      <elementRef key="line"/>
                                                      <elementRef key="surface"/>
                                                      <elementRef key="surfaceGrp"/>
                                                </alternate>
                                                
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
              <elementRef key="surface"/>
              <elementRef key="surface"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="n" usage="req">
              <gloss>le numéro de la surface dans l'ordre de lecture logique du testament</gloss>
            </attDef>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="will-page">
                  <gloss>page du testament</gloss>
                </valItem>
                <valItem ident="will-envelope-recto">
                  <gloss>enveloppe du testament : recto</gloss>
                </valItem>
                <valItem ident="will-envelope-verso">
                  <gloss>enveloppe du testament : verso</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><surfaceGrp type="will-page" n="02"
                  ><surface type="will-page-part" n="02a"><graphic
                    url="JPEG/FRAN_Poilus_t-0001_02a.jpg" xml:id="testament-0001_vue-02a_jpg"
                    > </graphic><graphic url="TIFF/FRAN_Poilus_t-0001_02a.tif"
                    xml:id="testament-0001_vue-02a_tif"/></surface><surface type="will-page-part"
                  n="02b"><graphic url="JPEG/FRAN_Poilus_t-0001_02b.jpg"
                    xml:id="testament-0001_vue-02b_jpg"/><graphic
                    url="TIFF/FRAN_Poilus_t-0001_02b.jpg" xml:id="testament-0001_vue-02b_tif"
                  /></surface></surfaceGrp></egXML>
          </exemplum>
        </elementSpec>
        <elementSpec ident="graphic" module="core" mode="replace">
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé, au sein d'un élément
              <gi>surface</gi>, pour consigner l'adresse relative et l'identifiant d'une image
            numérique reproduisant une surface physique d'un testament ou de son enveloppe. Doit
            obligatoirement avoir un attribut <att>url</att> et un attribut <att>xml:id</att></desc>
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <memberOf key="model.graphicLike"/>
            <!--    <memberOf key="model.titlepagePart"/>-->
            <!--  <memberOf key="att.media"/>-->
            <!-- <memberOf key="att.resourced"/>-->
            <!--    <memberOf key="att.declaring"/>-->
          </classes>
          <attList>
            <attDef ident="url" usage="req">
              <desc>L'adresse relative de l'image numérique</desc>
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="xml:id" usage="req">
              <desc>l'identifiant unique de l'image numérique (sera utilisé pour faire référence à
                cette image dans le corps de la transcription).</desc>
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><surface type="will-page" n="01"
                  ><graphic url="TIFF/FRAN_Poilus_t-0001_01.tif" xml:id="testament-0001_vue-01_jpg"
                  /><graphic url="JPEG/FRAN_Poilus_t-0001_01.jpg" xml:id="testament-0001_vue-01_tif"
                /></surface></egXML>
          </exemplum>
          <!-- <content>
                                <!-\-    <classRef key="model.descLike" minOccurs="0" maxOccurs="unbounded"/>   -\->
                              </content>-->
        </elementSpec>
        <elementSpec ident="text" module="textstructure" mode="replace">
          <gloss>texte</gloss>
          <desc type="wills-ui">Projet Testaments de Poilus : l'édition du testament. Cet élément
            possède obligatoirement un attribut <att>xml:id</att> qui donne un identifiant unique à
            l'édition. Il contient obligatoirement un élément <gi>body</gi>, qui englobe la
            transcription proprement dite et les notes d'apparat critique, et optionnellement un
            élément <gi>back</gi>, qui sert pour consigner les notes explicatives et commentaires
            divers associés à une partie de la transcription.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>
                                    <memberOf key="att.declaring"/>-->
            <!--  <memberOf key="att.typed"/>-->
            <!--   <memberOf key="att.written"/>-->
            <memberOf key="model.resourceLike"/>
          </classes>
          <content>
            <sequence>
              <!--   <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                          -->
              <!-- <sequence minOccurs="0">
                                                <elementRef key="front"/>
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                
                                          </sequence>-->
              <!-- <alternate>
                                                <elementRef key="body"/>
                                                <elementRef key="group"/>
                                          </alternate>-->
              <!--  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>-->
              <!--  <sequence minOccurs="0">
                                                <elementRef key="back"/>
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                
                                          </sequence>-->
              <elementRef key="body"/>
              <elementRef key="back" minOccurs="0" maxOccurs="1"/>
            </sequence>
          </content>
          <constraintSpec ident="textIdPattern" scheme="schematron">
            <constraint><sch:rule context="tei:text"><sch:assert
                  test="matches(@xml:id, 'will-\d\d\d\d')">l'identifiant du testament doit commencer
                  par le préfixe 'will-', puis un nombre sur quatre
              digits.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" usage="req">
              <desc>l'identifiant unique de l'édition d'un testament.</desc>
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><text xml:id="will-0001">
                <body><!-- ici, au moins une division de texte div --></body>
              </text></egXML>
          </exemplum>
          <!--<listRef>
                                    <ptr target="#DS"/>
                                    <ptr target="#CCDEF"/>
                              </listRef>-->
        </elementSpec>
        <elementSpec module="textstructure" ident="body" mode="replace">
          <gloss versionDate="2007-06-12">corps du texte</gloss>
          <desc versionDate="2007-06-12">contient la totalité du corps d’un seul texte simple, à
            l’exclusion de toute partie pré- ou post-liminaire.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient la totalité de la
            transcription du document, notes d'apparat critique incluses.</desc>
          <!-- <classes>
                                    <memberOf key="att.global"/>
                                    <memberOf key="att.declaring"/>
                              </classes>-->
          <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
            <elementRef key="div" minOccurs="1" maxOccurs="unbounded"/>
            <!--<sequence>
                                          <!-\- globals as usual -\->
                                          
                                          <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                          
                                          <!-\-possibly some divTops, interspersed with globals -\->
                                          
                                          <sequence minOccurs="0">
                                                
                                                <classRef key="model.divTop"/>
                                                
                                                
                                                <alternate minOccurs="0" maxOccurs="unbounded">
                                                      <classRef key="model.global"/>
                                                      <classRef key="model.divTop"/>
                                                </alternate>
                                                
                                          </sequence>
                                          
                                          <!-\- possibly some generated divs, interspersed with globals -\->
                                          
                                          <sequence minOccurs="0">
                                                
                                                <classRef key="model.divGenLike"/>
                                                
                                                
                                                <alternate minOccurs="0" maxOccurs="unbounded">
                                                      <classRef key="model.global"/>
                                                      <classRef key="model.divGenLike"/>
                                                </alternate>
                                                
                                          </sequence>
                                          
                                          
                                          <!-\- 
	   now a choice between
	   
	   a) some divLike things, with globals and generated divs
	     after them if needed 
	   b) some div1Like things, with globals
	     and generated divs after them if needed 
	   c) same again, preceded by model.common
      -\->
                                          <alternate>
                                                <!-\- a -\->
                                                
                                                <sequence minOccurs="1" maxOccurs="unbounded">
                                                      
                                                      <classRef key="model.divLike"/>
                                                      
                                                      
                                                      <alternate minOccurs="0" maxOccurs="unbounded">
                                                            <classRef key="model.global"/>
                                                            <classRef key="model.divGenLike"/>
                                                      </alternate>
                                                      
                                                </sequence>
                                                
                                                <!-\- b -\->
                                                
                                                <sequence minOccurs="1" maxOccurs="unbounded">
                                                      
                                                      <classRef key="model.div1Like"/>
                                                      
                                                      
                                                      <alternate minOccurs="0" maxOccurs="unbounded">
                                                            <classRef key="model.global"/>
                                                            <classRef key="model.divGenLike"/>
                                                      </alternate>
                                                      
                                                </sequence>
                                                
                                                <!-\- c -\->
                                                <sequence>
                                                      <sequence minOccurs="1" maxOccurs="unbounded">
                                                            
                                                            <classRef key="model.common"/>
                                                            
                                                            
                                                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                            
                                                      </sequence>
                                                      
                                                      <alternate minOccurs="0">
                                                            <!-\- a -\->
                                                            
                                                            <sequence minOccurs="1" maxOccurs="unbounded">
                                                                  
                                                                  <classRef key="model.divLike"/>
                                                                  
                                                                  
                                                                  <alternate minOccurs="0" maxOccurs="unbounded">
                                                                        <classRef key="model.global"/>
                                                                        <classRef key="model.divGenLike"/>
                                                                  </alternate>
                                                                  
                                                            </sequence>
                                                            
                                                            <!-\- b -\->
                                                            
                                                            <sequence minOccurs="1" maxOccurs="unbounded">
                                                                  
                                                                  <classRef key="model.div1Like"/>
                                                                  
                                                                  
                                                                  <alternate minOccurs="0" maxOccurs="unbounded">
                                                                        <classRef key="model.global"/>
                                                                        <classRef key="model.divGenLike"/>
                                                                  </alternate>
                                                                  
                                                            </sequence>
                                                            
                                                      </alternate>
                                                      
                                                </sequence>
                                          </alternate>
                                          <!-\- end of choice -\->
                                          
                                          <!-\- finally, some divBottoms interspersed with globals  -\->
                                          
                                          <sequence minOccurs="0" maxOccurs="unbounded">
                                                
                                                <classRef key="model.divBottom"/>
                                                
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                
                                          </sequence>
                                          
                                    </sequence>-->
          </content>
          <!--  <exemplum xml:lang="mul">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples" source="#caedmon" xml:lang="ang">
                                          <body>
                                                <l>Nu scylun hergan hefaenricaes uard</l>
                                                <l>metudæs maecti end his modgidanc</l>
                                                <l>uerc uuldurfadur sue he uundra gihuaes</l>
                                                <l>eci dryctin or astelidæ</l>
                                                <l>he aerist scop aelda barnum</l>
                                                <l>heben til hrofe haleg scepen.</l>
                                                <l>tha middungeard moncynnæs uard</l>
                                                <l>eci dryctin æfter tiadæ</l>
                                                <l>firum foldu frea allmectig</l>
                                                <trailer>primo cantauit Cædmon istud carmen.</trailer>
                                          </body>
                                    </egXML>
                              </exemplum>-->
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><body>
                <div type="will"><!-- transcription du texte du testament proprement dit --></div>
                <div type="envelope"
                  ><!-- transcription du texte de l'enveloppe lorsque celle-ci subsiste et porte des mentions de la main du testateur --></div>
              </body></egXML>
          </exemplum>
          <!--  <listRef>
                                    <ptr target="#DS"/>
                              </listRef>-->
        </elementSpec>
        <elementSpec module="textstructure" ident="div" mode="replace">
          <gloss versionDate="2007-06-12">division du texte</gloss>
          <desc versionDate="2007-06-12">contient une subdivision dans le texte préliminaire, dans
            le corps d’un texte ou dans le texte postliminaire.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : pour ce qui est de la transcription;
              <gi>div</gi> englobe soit le texte du testament, soit le texte d'une enveloppe.
              <gi>div</gi> est aussi utilisé pour englober les notes explicatives et commentaires
            dans l'élément <gi>back</gi>. </desc>
          <classes>
            <!--   <memberOf key="att.global"/>-->
            <!--  <memberOf key="att.divLike"/>-->
            <!--  <memberOf key="att.typed"/>-->
            <!-- <memberOf key="att.declaring"/>-->
            <!-- <memberOf key="att.written"/>-->
            <memberOf key="model.divLike"/>
          </classes>
          <content>
            <alternate>
              <sequence>
                <elementRef key="pb" minOccurs="1" maxOccurs="1"/>
                <alternate>
                  <sequence>
                    <elementRef key="head" minOccurs="1" maxOccurs="1"/>
                    <elementRef key="dateline" minOccurs="0" maxOccurs="unbounded"/>
                  </sequence>
                  <sequence>
                    <elementRef key="dateline" minOccurs="0" maxOccurs="unbounded"/>
                    <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                  </sequence>
                </alternate>
                <sequence minOccurs="1" maxOccurs="unbounded">
                  <elementRef key="p" minOccurs="1" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="list" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                </sequence>
                <sequence>
                  <elementRef key="dateline" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="signed" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="postscript" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="signed" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="dateline" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="postscript" minOccurs="0" maxOccurs="unbounded"/>
                  <alternate>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                    </sequence>
                    <sequence>
                      <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                      <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </alternate>
                  <elementRef key="signed" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <!-- signed, dateline, postscript-->
                <!-- signed peut être tout seul -->
                <!-- séquence la plus courante : dateline, signed -->
                <!-- n dateline, n postcript, 1 signed au moins -->
                <!--<elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="dateline" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="signed" minOccurs="1"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="dateline" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="postscript" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="1"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>-->
                <!-- <alternate minOccurs="0" maxOccurs="unbounded">
                                                <classRef key="model.divTop"/>
                                                <!-\-        <rng:ref name="model.headLike"/>-\->
                                                <classRef key="model.global"/>
                                          </alternate>-->
                <!-- <sequence>
                                                       <elementRef key="dateline" minOccurs="0"
                                                                  maxOccurs="unbounded"/>
                                                        <elementRef key="signed" minOccurs="1"
                                                                  maxOccurs="unbounded"/>
                                                        <elementRef key="postcript" minOccurs="0"
                                                                  maxOccurs="unbounded"/>
                                                </sequence>
                                                
                                                    -->
                <!--  
                                                <alternate minOccurs="1" maxOccurs="1">
                                                  <elementRef key="dateline" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="signed" minOccurs="1"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="postcript" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="space" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="metamark" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                  <elementRef key="pb" minOccurs="0"
                                                  maxOccurs="unbounded"/>
                                                </alternate>-->
                <!--<sequence minOccurs="0">
                                                <alternate>
                                                      
                                                      <sequence minOccurs="1" maxOccurs="unbounded">
                                                            <alternate>
                                                                  <classRef key="model.divLike"/>
                                                                  <classRef key="model.divGenLike"/>
                                                            </alternate>
                                                            
                                                            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                            
                                                      </sequence>
                                                      
                                                      <sequence>
                                                            <sequence minOccurs="1" maxOccurs="unbounded">
                                                                  
                                                                  <classRef key="model.common"/>
                                                                  
                                                                  
                                                                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                                  
                                                            </sequence>
                                                            <sequence minOccurs="0" maxOccurs="unbounded">
                                                                  <alternate>
                                                                        <classRef key="model.divLike"/>
                                                                        <classRef key="model.divGenLike"/>
                                                                  </alternate>
                                                                  
                                                                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                                  
                                                            </sequence>
                                                      </sequence>
                                                </alternate>
                                                <sequence minOccurs="0" maxOccurs="unbounded">
                                                      
                                                      <classRef key="model.divBottom"/>
                                                      
                                                      
                                                      <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                      
                                                </sequence>
                                          </sequence>-->
              </sequence>
              <sequence>
                <elementRef key="note" minOccurs="1" maxOccurs="unbounded"/>
              </sequence>
            </alternate>
          </content>
          <constraintSpec ident="abstractModel-structure-l" scheme="schematron">
            <constraint><report xmlns="http://purl.oclc.org/dsdl/schematron" test="ancestor::tei:l">
                Abstract model violation: Lines may not contain higher-level structural elements
                such as div. </report></constraint>
          </constraintSpec>
          <constraintSpec ident="abstractModel-structure-p" scheme="schematron">
            <constraint><report xmlns="http://purl.oclc.org/dsdl/schematron"
                test="ancestor::tei:p or ancestor::tei:ab and not(ancestor::tei:floatingText)">
                Abstract model violation: p and ab may not contain higher-level structural elements
                such as div. </report></constraint>
          </constraintSpec>
          <constraintSpec ident="contentIfTypeWill" scheme="schematron">
            <constraint><sch:rule context="tei:div[@type='will']"><sch:assert
                  test="tei:p and tei:signed">Il doit au moins y avoir un élément fils p et un
                  élément descendant signed</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="contentIfTypeEnvelope" scheme="schematron">
            <constraint><sch:rule context="tei:div[@type='envelope']"><sch:assert test="tei:p">Il
                  doit au moins y avoir un élément fils p</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="contentIfTypeNotes" scheme="schematron">
            <constraint><sch:rule context="tei:div[@type='notes']"><sch:assert test="tei:note">Il
                  doit au moins y avoir un élément fils note</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="will">
                  <gloss>le texte du testament</gloss>
                </valItem>
                <valItem ident="envelope">
                  <gloss>le texte de l'enveloppe</gloss>
                </valItem>
                <valItem ident="notes">
                  <gloss>notes</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <!--    <attList>
                                    <attRef name=""/>
                              </attList>-->
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="will"
                  ><pb/><!-- indication de la première page du testament --><dateline><!-- ligne de date--></dateline><head><!-- titre du testament--></head><p><!-- un paragraphe du testament--></p><p><!-- un paragraphe du testament--></p><pb/><!-- changement de page --><list><!-- une liste (souvent une liste de biens) --><item/><item/></list><p><!-- un paragraphe --></p><dateline><!-- ligne de date--></dateline><signed><!-- signature --></signed><postscript><!-- postscriptum --></postscript></div></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="notes"
              ><note/><note/></div></egXML>
          </exemplum>
        </elementSpec>
        <elementSpec module="core" ident="head" mode="replace">
          <gloss versionDate="2009-01-06">en-tête</gloss>
          <desc versionDate="2009-01-06">contient tout type d'en-tête, par exemple le titre d'une
            section, ou l'intitulé d'une liste, d'un glossaire, d'une description de manuscrit,
            etc.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient le titre du testament,
            lorsque le testateur en a écrit un en tête de celui-ci, avant ou après la mention de la
            date si elle existe, en le centrant en général sur la page. Le plus souvent ce titre est
            le suivant : "Ceci est mon testament", ou une expression ayant la même
            signification.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <!-- <memberOf key="att.typed"/>-->
            <memberOf key="att.placement"/>
            <!--<memberOf key="att.written"/>-->
            <memberOf key="model.headLike"/>
            <memberOf key="model.pLike.front"/>
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!-- <elementRef key="lg"/>-->
              <!--<classRef key="model.gLike"/>-->
              <!-- <classRef key="model.phrase"/>-->
              <!-- <classRef key="model.inter"/>-->
              <!--<classRef key="model.lLike"/>-->
              <!-- <classRef key="model.global"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="seg"/>
              <elementRef key="persName"/>
              <elementRef key="placeName"/>
              <elementRef key="orgName"/>
              <elementRef key="date"/>
              <elementRef key="ref"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
            </alternate>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><head>Ceci est mon
                    testament<choice><reg>.</reg><orig> : </orig></choice></head></egXML>
          </exemplum>
          <listRef>
            <!--    <ptr target="#COLI" type="div2"/>-->
            <ptr target="#DSHD" type="div2"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textstructure" ident="dateline" mode="replace">
          <gloss versionDate="2007-06-12">mention de date</gloss>
          <desc versionDate="2007-06-12">contient une brève description des lieux, date, heure, etc.
            concernant la production d’une lettre, d’un article de journal ou d’un autre texte qui,
            placée au début ou à la fin, lui est associée comme en-tête ou annonce de fin.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.divWrapper"/>
          </classes>
          <content>
            <!-- MDH 2013-11-11: per http://sourceforge.net/p/tei/feature-requests/472/ adding 
      docDate to the content model, so it now has to be explicit instead of 
      macro.phraseSeq. -->
            <!-- <ref xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="persName"/>
              <elementRef key="placeName"/>
              <elementRef key="orgName"/>
              <elementRef key="date"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <attList>
            <attDef ident="rend" usage="opt">
              <valList type="open">
                <valItem ident="centered">
                  <gloss>centré</gloss>
                </valItem>
                <valItem ident="right">
                  <gloss>à droite</gloss>
                </valItem>
                <valItem ident="left">
                  <gloss>à gauche</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="centered"
                  ><placeName>Paris</placeName><choice><orig/><reg>,</reg></choice> le
                      <date><choice><orig>trente et
                      un</orig><reg>trente-et-un</reg></choice><choice><reg> juillet</reg><orig>
                      Juillet</orig></choice><lb/><choice><orig>mil</orig><reg>mille</reg></choice>
                  neuf cent quatorze<lb/> (31
                    <choice><reg>juillet</reg><orig>Juillet</orig></choice>
              1914)</date></dateline></egXML>
          </exemplum>
          <listRef>
            <ptr target="#DSOC"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="list" mode="replace">
          <gloss versionDate="2007-06-12">liste</gloss>
          <desc versionDate="2007-06-12">contient une suite d'items ordonnés dans une liste.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé le plus souvent pour encoder
            une liste de biens dans le corps d'un testament.</desc>
          <classes>
            <!--<memberOf key="att.global"/>
    <memberOf key="att.sortable"/>
    <memberOf key="att.typed"/>-->
            <memberOf key="model.listLike"/>
          </classes>
          <!-- 	    <rng:zeroOrMore>
              <rng:ref name="model.global"/>
              </rng:zeroOrMore> -->
          <!-- The removal of this component (and the same one after <headItem> is-->
          <!-- wrong, and breaks the content model. The right thing to do, IMHO,-->
          <!-- is to leave these in, and either-->
          <!-- * improve the ODD -> DTD process so that it does the right thing-->
          <!--   (which would probably be very hard)-->
          <!-- * require the user to fix the content model if & when she removes-->
          <!--   <headItem> or <headLabel>-->
          <!-- I haven't fixed this particular instance yet, because we hope to-->
          <!-- completely revamp the content of <list>, anyway, hopefully-->
          <!-- removing the special-purpose <headItem> and <headLabel>. -Syd -->
          <!--<content>
    <sequence>
      
        <alternate minOccurs="0" maxOccurs="unbounded">
          
            <classRef key="model.divTop"/>
          
          
            <classRef key="model.global"/>
          
        </alternate>
      
      <alternate>
        <sequence minOccurs="1" maxOccurs="unbounded">
          <elementRef key="item"/>
          
            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
          
        </sequence>
        <sequence>
          
            <elementRef key="headLabel" minOccurs="0"/>
          
          
            <elementRef key="headItem" minOccurs="0"/>
          
          <sequence minOccurs="1" maxOccurs="unbounded">
            <elementRef key="label"/>
            
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            
            <elementRef key="item"/>
            
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            
          </sequence>
        </sequence>
      </alternate>
      
        <sequence minOccurs="0" maxOccurs="unbounded">
          
            <classRef key="model.divBottom"/>
          
          
            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
          
        </sequence>
      
    </sequence>
  </content>-->
          <!--  <content>
                              <alternate minOccurs="0" maxOccurs="unbounded">
                                    
                                    <!-\-<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-\->
                                    <elementRef key="item"/>
                                    <elementRef key="lb"/>
                                    <elementRef key="pb"/>
                                   <elementRef key="space"/>
                                    <elementRef key="metamark"/>
                                  
                                   
                                    <!-\-<classRef key="model.pPart.transcriptional"/>-\->
                                 
                              </alternate>
                              </content> -->
          <content>
            <sequence minOccurs="1" maxOccurs="unbounded">
              <alternate>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </alternate>
              <elementRef key="item" minOccurs="1" maxOccurs="unbounded"/>
              <alternate>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </alternate>
            </sequence>
          </content>
          <constraintSpec ident="ifListThenItem" scheme="schematron">
            <constraint><sch:rule context="tei:list"><sch:assert test="tei:item">Une liste doit
                  contenir au moins un item</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 47
              (Alexandre Victor Titard, 3 août 1914) », dans <title>Testaments de guerre de Poilus
                parisiens (1914-1918) : une édition critique</title>. Paris : École nationale des
              chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-047.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-047.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><list><item>Créance Clémançon chez
                        <choice><abbr>M<hi rend="sup"
                    >e</hi></abbr><expan>M<ex>aîtr</ex>e</expan></choice> Delafon 6
                        <choice><abbr>B<hi rend="sup"
                    >d</hi></abbr><expan>b<ex>oulevar</ex>d</expan></choice> de
                  Strasbourg</item><item>Immeuble
                      <choice><expan>S<ex>ain</ex>t-Fargeau</expan><abbr>St Fargeau</abbr></choice>
                  chez <choice><abbr>M.</abbr><expan>M<ex>aître</ex></expan></choice> Cros notaire à
                  Corbeil</item><!-- [...] --></list></egXML>
          </exemplum>
          <!-- 
                              <content>
                                    <sequence minOccurs="1" maxOccurs="unbounded">
                                          <elementRef key="item"/>
                                    </sequence>
                              </content>-->
          <!--  <constraintSpec xmlns:sch="http://purl.oclc.org/dsdl/schematron" ident="gloss-list-must-have-labels" scheme="schematron">
    <constraint>
      <sch:rule context="tei:list[@type='gloss']">
	<sch:assert test="tei:label">The content of a "gloss" list should include a sequence of one or more pairs of a label element followed by an item element</sch:assert>
      </sch:rule>
    </constraint>
  </constraintSpec>-->
          <!--<attList>
<!-\-    MDH 2014-08-31: I'm removing an override of @rend which was last present in rev 12971, per discussions
        on the Council list. Its original purpose was to provide a guided transition between the old uses of 
        @type and the new recommendation to use @rend, but the general consensus is that providing suggestions
        in the prose is better than formalizing them in the ODD.
    -\->
    
    <attDef ident="type" usage="opt" mode="change">
      <gloss versionDate="2017-06-25" xml:lang="de">Typ</gloss>
      <desc versionDate="2014-07-29" xml:lang="en">describes the nature of the items in the list.</desc>
      <desc versionDate="2016-11-25" xml:lang="de">beschreibt die Art der Listenpunkte.</desc>
      <datatype><dataRef key="teidata.enumerated"/></datatype>
      <valList type="semi" mode="add">
        <valItem ident="gloss">
          <gloss versionDate="2017-06-25" xml:lang="de">Gloss</gloss>
          <desc versionDate="2016-11-25" xml:lang="en">each list item glosses some term or concept, which is given by a <gi>label</gi> element
            preceding the list item.</desc>
          <desc versionDate="2007-12-20" xml:lang="ko">목록의 각 항목은 선행하는 요소에서 제시된 용어 또는 개념에 대한 설명이다.</desc>
          <desc versionDate="2007-05-02" xml:lang="zh-TW">各列表項目為一些字詞或概念下註解，每個項目之前並帶有標籤元素。</desc>
          <desc versionDate="2008-04-06" xml:lang="es">cada item de la lista glosa algun término o
            concepto de los que han sido dados por un elemento de la lista de la etiqueta que
            precede.</desc>
          <desc versionDate="2008-04-05" xml:lang="ja">リスト項目は，当該リスト項目に先行してあるラベル要素で示され
            たある用語や意義をまとめたものである．</desc>
          <desc versionDate="2008-03-30" xml:lang="fr">chaque item de la liste commente un terme ou un
            concept qui est donné par un élément <gi>label</gi> précédant l'item de la liste.</desc>
          <desc versionDate="2007-01-21" xml:lang="it">ogni voce dell'elenco è la glossa di un termine o
            concetto dato da un elemento legenda che precede la voce stessa</desc>
            <desc versionDate="2016-11-25" xml:lang="de">jeder Listenpunkt erläutert einen Begriff oder ein Konzept, das von einem voranstehenden <gi>label</gi>-Element genannt wird.</desc>
        </valItem>
        <valItem ident="index">
          <gloss versionDate="2017-06-25" xml:lang="de">Index</gloss>
          <desc versionDate="2014-05-04" xml:lang="en">each list item is an entry in an index such as the alphabetical topical index 
          at the back of a print volume.</desc>
            <desc versionDate="2016-11-25" xml:lang="de">jeder Listenpunkt ist ein Registereintrag z. B. in einem alphabetisch geordneten 
                Sachregister am Ende einer Druckausgabe.</desc>
        </valItem>
        <valItem ident="instructions">
          <gloss versionDate="2017-06-25" xml:lang="de">Arbeitsschritt</gloss>
          <desc versionDate="2014-05-04" xml:lang="en">each list item is a step in a sequence of instructions, as in a
            recipe.</desc>
            <desc versionDate="2016-11-25" xml:lang="de">jeder Listenpunkt ist ein Arbeitsschritt in einer Folge von Anweisungen, 
                wie z. B. in einem Rezept.</desc>
        </valItem>
        <valItem ident="litany">
          <gloss versionDate="2017-06-25" xml:lang="de">Litanei</gloss>
          <desc versionDate="2014-05-04" xml:lang="en">each list item is one of a sequence of petitions, supplications 
            or invocations, typically in a religious ritual.</desc>
            <desc versionDate="2016-11-25" xml:lang="de">jeder Listenpunkt ist Teil einer Reihenfolge von Gebeten, Bitten oder Anrufungen die 
                üblicherweise in einem religiösen Ritual verwendet werden.</desc>
        </valItem>
        <valItem ident="syllogism">
          <gloss versionDate="2017-06-25" xml:lang="de">logischer Schluss</gloss>
          <desc versionDate="2014-05-04" xml:lang="en">each list item is part of an argument consisting of two or more propositions 
            and a final conclusion derived from them.</desc>
            <desc versionDate="2016-11-25" xml:lang="de">jeder Listenpunkt ist Teil eines Arguments, das aus zwei oder mehr Prämissen 
                und einem daraus gezogenen Schluss besteht.</desc>
        </valItem>
      </valList>
      <remarks versionDate="2014-07-30" xml:lang="en">
        <p>Previous versions of these Guidelines recommended the use
        of <att>type</att> on <gi>list</gi> to encode the rendering or
        appearance of a list (whether it was bulleted, numbered,
        etc.). The current recommendation is to use the
        <att>rend</att> or <att>style</att> attributes for these
        aspects of a list, while using <att>type</att> for the more
        appropriate task of characterizing the nature of the content
        of a list.</p>
      </remarks>
      <remarks versionDate="2005-01-14" xml:lang="en">
        <p>The formal syntax of the element declarations allows
        <gi>label</gi> tags to be omitted from lists tagged <tag>list
        type="gloss"</tag>; this is however a semantic error.</p>
      </remarks>
      <remarks xml:lang="fr" versionDate="2007-06-12">
        <p>La syntaxe formelle des déclarations d'élément permet d'omettre les étiquettes de balises
          des listes balisées par <tag>list type="gloss"</tag> mais c'est une erreur sémantique.</p>
      </remarks>
      <remarks xml:lang="ja" versionDate="2008-04-05">
        <p> 当該要素の宣言では，要素<gi>label</gi>は，タグ<tag>list type="gloss"</tag>中で省略することができることになっているが，
          これは意味上のエラーになる． </p>
      </remarks>
      <remarks versionDate="2016-11-25" xml:lang="de">
          <p>In älteren Versionen dieser Richtlinien wurde empfohlen, mit dem Attribut <att>type</att> am <gi>list</gi>-Element 
              die Darstellung oder das Erscheinungsbild einer Liste zu kodieren (also ob sie z. B. nummeriert oder mit Symbolen 
              versehen ist). Die aktuelle Empfehlung ist, dafür die Attribute <att>rend</att> oder <att>style</att> zu verwenden, 
              während mit <att>type</att> der Inhalt der Liste charakterisiert werden sollte.</p>
      </remarks>
        <remarks versionDate="2016-11-25" xml:lang="de">
            <p>Die formale Syntax der Elementdeklaration 
                erlaubt es, Listen vom <tag>list type="gloss"</tag> ohne das Element <gi>label</gi> zu verwenden; das ist jedoch ein 
                semantischer Fehler.</p>
        </remarks>
    </attDef>
  </attList>-->
          <!--<remarks xml:lang="fr" versionDate="2007-06-12">
    <p rend="dataDesc">Peut contenir un titre facultatif suivi d'une succession d'items ou d'une
      succession de couples constitués d'une étiquette et d'un item, ce dernier type pouvant être
      précédé par un ou deux titres spécifiques.</p>
  </remarks>-->
          <listRef>
            <ptr target="#COLI" type="div2"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="item" mode="replace">
          <gloss>composant de liste (item)</gloss>
          <desc versionDate="2009-01-06">contient un composant d'une liste.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé le plus souvent pour encoder
            la description d'un bien dans une liste.</desc>
          <classes><!-- <memberOf key="att.global"/>
                                    <memberOf key="att.sortable"/>--></classes>
          <!--<content>
                                    <macroRef key="macro.specialPara"/>
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="persName"/>
              <elementRef key="placeName"/>
              <elementRef key="orgName"/>
              <elementRef key="date"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <attList>
            <attDef ident="rend" usage="opt">
              <valList type="open">
                <valItem ident="centered">
                  <gloss>centré</gloss>
                </valItem>
                <valItem ident="right">
                  <gloss>à droite</gloss>
                </valItem>
                <valItem ident="left">
                  <gloss>à gauche</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 47
              (Alexandre Victor Titard, 3 août 1914) », dans <title>Testaments de guerre de Poilus
                parisiens (1914-1918) : une édition critique</title>. Paris : École nationale des
              chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-047.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-047.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><list><item>Créance Clémançon chez
                        <choice><abbr>M<hi rend="sup"
                    >e</hi></abbr><expan>M<ex>aîtr</ex>e</expan></choice> Delafon 6
                        <choice><abbr>B<hi rend="sup"
                    >d</hi></abbr><expan>b<ex>oulevar</ex>d</expan></choice> de
                  Strasbourg</item><item>Immeuble
                      <choice><expan>S<ex>ain</ex>t-Fargeau</expan><abbr>St Fargeau</abbr></choice>
                  chez <choice><abbr>M.</abbr><expan>M<ex>aître</ex></expan></choice> Cros notaire à
                  Corbeil</item><!-- [...] --></list></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COLI" type="div2"/>
            <ptr target="#HD6"/>
          </listRef>
        </elementSpec>
        <elementSpec module="linking" ident="seg" mode="replace">
          <gloss versionDate="2007-06-12">segment quelconque (de texte)</gloss>
          <!--   <gloss versionDate="2005-01-14" xml:lang="en">arbitrary segment</gloss>-->
          <!-- <desc versionDate="2008-01-31" xml:lang="en">represents any segmentation of text below the <soCalled>chunk</soCalled> level.</desc>-->
          <desc versionDate="2009-10-06">contient une unité de texte quelconque de niveau
              <soCalled>segment</soCalled>.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé notamment pour encoder, dans
              <gi>signed</gi> ou directement dans un paragraphe ou un post-scriptum, une signature.
            Devrait normalement avoir un attribut <att>type</att> pour catégoriser le
            segment.</desc>
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <memberOf key="model.segLike"/>
            <!-- <memberOf key="att.segLike"/>
                                    <memberOf key="att.typed"/>
                                    <memberOf key="att.written"/>-->
            <memberOf key="model.choicePart"/>
            <memberOf key="model.linePart"/>
          </classes>
          <!--  <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <constraintSpec ident="ifSegThenAttrType" scheme="schematron">
            <constraint><sch:rule context="tei:seg"><sch:assert test="@type">Vous devriez
                  catégoriser le segment textuel à l'aide de l'attribut
              type</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="rec">
              <valList type="closed">
                <valItem ident="signature">
                  <gloss>une signature proprement dite</gloss>
                </valItem>
                <valItem ident="address">
                  <gloss>une adresse</gloss>
                </valItem>
                <valItem ident="other">
                  <gloss>autre catégorie de segment</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Extrait tiré de Nougaret (Christine),
                Clavaud (Florence) (dirs.), « Testament n° 8 (Lucien Dufriche, 1<hi
                  rend="superscript">er</hi> août 1914) », dans <title>Testaments de guerre de
                  Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
                nationale des chartes, 2017-.... En ligne : <ref
                  target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-008.html#transcription"
                  >
                  http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-008.html</ref>.</p><signed
                rend="right"><seg type="signature"><persName ref="#LDufriche"
                      ><forename>L.</forename><surname>Dufriche</surname></persName></seg><lb/> 8
                      <choice><orig><hi rend="superscript-underlined"
                  >bis</hi></orig><reg>bis</reg></choice> rue Sarrette </signed></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Extrait tiré de Nougaret (Christine),
                Clavaud (Florence) (dirs.), « Testament n° 33 (Henri Gé, 2 août 1914) », dans
                  <title>Testaments de guerre de Poilus parisiens (1914-1918) : une édition
                  critique</title>. Paris : École nationale des chartes, 2017-.... En ligne : <ref
                  target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-033.html#transcription"
                  >
                  http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-033.html</ref>.</p><postscript><p>J’ai
                  des titres en dépôt à la<lb/> Société
                      <choice><reg>générale</reg><orig>Générale</orig></choice> sur lesquels<lb/>
                  j’ai fait un emprunt ; il<lb/> serait préférable de le rembourser<lb/> et de
                  vendre par la suite avec<lb/> bénéfice si possible.</p><p><seg type="signature"
                    rend="right"><persName ref="#HGe">H.
                <surname>Gé</surname></persName></seg></p></postscript></egXML>
          </exemplum>
          <!--<remarks versionDate="2012-04-20" xml:lang="en">
                                    <p>The <gi>seg</gi> element may be used at the encoder's discretion to mark any segments of the text of interest for processing. One use of the element is to mark text features for which no appropriate markup is otherwise defined. Another use is to provide an identifier for some segment which is to be pointed at by some other element—i.e. to provide a target, or a part of a target, for a <gi>ptr</gi> or other similar element.</p>
                              </remarks>-->
          <!--<remarks xml:lang="fr" versionDate="2009-10-06">
                                    <p>L'élément <gi>seg</gi> peut être utilisé à la discrétion de l'encodeur pour baliser tout segment du texte intéressant pour un traitement informatique. L'un des usages de cet élément est d'encoder des caractéristiques textuelles pour lesquelles aucun balisage approprié n'est défini par ailleurs. Un autre usage consiste à fournir un identifiant pour un segment vers lequel pointe un autre élément - c'est-à-dire à fournir une cible, ou une partie de cible, pour un élément <gi>ptr</gi> ou pour un autre élément similaire.</p>
                              </remarks>-->
          <listRef>
            <ptr target="#SASE"/>
            <ptr target="#VESE"/>
            <ptr target="#DRPAL"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textstructure" ident="signed" mode="replace">
          <gloss>signature</gloss>
          <!-- <gloss versionDate="2005-01-14" xml:lang="en">signature</gloss>-->
          <!--<desc versionDate="2005-01-14" xml:lang="en">contains the closing salutation, etc., appended to a foreword,
                                    dedicatory epistle, or other division of a text.</desc>-->
          <desc versionDate="2008-10-02">contient la dernière salutation, ajoutée à un avant-propos,
            à une dédicace ou à une autre division du texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : ce segment de texte peut contenir,
            outre la signature proprement dite du testament ou de l'enveloppe, une salutation ou
            autre formule d'accompagnement, une adresse, une date, etc. On peut, à l'aide de
            l'attribut <att>rend</att>, en préciser la position sur la page.</desc>
          <classes>
            <!--  <memberOf key="att.global"/>
                                    <memberOf key="att.written"/>-->
            <memberOf key="model.divBottomPart"/>
            <memberOf key="model.divTopPart"/>
          </classes>
          <!-- <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <attList>
            <attDef ident="rend" usage="opt">
              <valList type="open">
                <valItem ident="centered">
                  <gloss>centré</gloss>
                </valItem>
                <valItem ident="right">
                  <gloss>à droite</gloss>
                </valItem>
                <valItem ident="left">
                  <gloss>à gauche</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Extrait tiré de Nougaret (Christine),
                Clavaud (Florence) (dirs.), « Testament n° 8 (Lucien Dufriche, 1<hi
                  rend="superscript">er</hi> août 1914) », dans <title>Testaments de guerre de
                  Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
                nationale des chartes, 2017-.... En ligne : <ref
                  target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-008.html#transcription"
                  >
                  http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-008.html</ref>.</p><signed
                rend="right"><seg type="signature"><persName ref="#LDufriche"
                      ><forename>L.</forename><surname>Dufriche</surname></persName></seg><lb/> 8
                      <choice><orig><hi rend="superscript-underlined"
                  >bis</hi></orig><reg>bis</reg></choice> rue Sarrette </signed></egXML>
          </exemplum>
          <listRef>
            <ptr target="#DSOC"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textstructure" ident="postscript" mode="replace">
          <gloss>post-scriptum</gloss>
          <!--  <desc versionDate="2007-08-04" xml:lang="en">contains a postscript, e.g. to a letter.</desc>-->
          <desc versionDate="2008-03-30">contient un post-scriptum, par exemple au bas d' une
            lettre.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : un testament peut avoir plusieurs
            post-scripta successifs, parfois signés.</desc>
          <classes>
            <!--<memberOf key="att.global"/>
                                    <memberOf key="att.written"/>-->
            <memberOf key="model.divBottomPart"/>
          </classes>
          <content>
            <sequence>
              <alternate>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </alternate>
              <elementRef key="p" minOccurs="1" maxOccurs="unbounded"/>
              <alternate>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </alternate>
              <elementRef key="list" minOccurs="0" maxOccurs="unbounded"/>
              <alternate>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                </sequence>
                <sequence>
                  <elementRef key="space" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="pb" minOccurs="0" maxOccurs="1"/>
                  <elementRef key="metamark" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </alternate>
            </sequence>
            <elementRef key="signed" minOccurs="0" maxOccurs="unbounded"/>
          </content>
          <!--<content>
                                    <alternate minOccurs="0" maxOccurs="unbounded">
                                         <!-\- <textNode/>-\->
                                          <!-\-<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-\->
                                          <elementRef key="p"/>
                                         
                                          <elementRef key="pb"/>
                                         <!-\- <elementRef key="choice"/>
                                          <elementRef key="gap"/>
                                          <elementRef key="unclear"/>
                                          <elementRef key="supplied"/>
                                          <elementRef key="damage"/>
                                          <elementRef key="add"/>
                                          <elementRef key="del"/>
                                          <elementRef key="subst"/>
                                          <elementRef key="app"/>
                                          <elementRef key="hi"/>-\->
                                          <!-\-<classRef key="model.pPart.transcriptional"/>-\->
                                         <!-\- <elementRef key="placeName"/>
                                          <elementRef key="date"/>-\->
                                          <elementRef key="seg"/>
                                          <elementRef key="list"/>
                                          <elementRef key="signed"/>
                                    </alternate>
                              </content>-->
          <!--<content>
                                    <sequence>
                                          
                                          <alternate minOccurs="0" maxOccurs="unbounded">
                                                <classRef key="model.global"/>
                                                <classRef key="model.divTopPart"/>
                                          </alternate>
                                          
                                          
                                          <classRef key="model.common"/>
                                          
                                          
                                          <alternate minOccurs="0" maxOccurs="unbounded">
                                                <classRef key="model.global"/>
                                                <classRef key="model.common"/>
                                          </alternate>
                                          
                                          <sequence minOccurs="0" maxOccurs="unbounded">
                                                
                                                <classRef key="model.divBottomPart"/>
                                                
                                                
                                                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                                                
                                          </sequence>
                                    </sequence>
                              </content>-->
          <exemplum>
            <p>Louis Charles Eugène Le Conte</p>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 74
              (Louis Charles Eugène Le Conte, 16 novembre 1914) », dans <title>Testaments de guerre
                de Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
              nationale des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-074.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-074.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><signed rend="right"><seg
                  type="signature"><persName ref="#LeConte">Louis <surname>Le
                    Conte</surname></persName></seg></signed><space dim="vertical" quantity="1"
                unit="lines"/><postscript><p>Pas de fleurs, ni de couronnes, un enterrement
                  simple<lb/> mais beaucoup de messes, en particulier les 33 messes grégoriennes<lb/>
                  <pb/> dites le plus tôt possible après mon
                    décès<choice><orig/><reg>,</reg></choice> et des prières.<lb/> Je ne fais aucune
                  recommandation spéciale par écrit, mon<lb/> vœu le plus cher est que mes enfants
                  soient tous de <hi rend="underlined">bons chrétiens</hi><lb/>
                  <!-- [...] -->
                </p><signed rend="right"><seg type="signature"><persName ref="#LeConte">Louis
                      Charles Eugène <surname>Le
                Conte</surname></persName></seg></signed></postscript></egXML>
          </exemplum>
          <listRef>
            <ptr target="#DSDTB"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="p" mode="replace">
          <gloss versionDate="2009-01-06">paragraphe</gloss>
          <desc versionDate="2009-01-06">marque les paragraphes dans un texte en prose.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : c'est le principal composant du texte
            des testaments.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pLike"/>
            <!-- <memberOf key="att.declaring"/>
                                    <memberOf key="att.fragmentable"/>
                                    <memberOf key="att.written"/>-->
          </classes>
          <!--  <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!-- MDH 2013-11-11: per http://sourceforge.net/p/tei/feature-requests/472/ adding 
      docDate to the content model, so it now has to be explicit instead of 
      macro.phraseSeq. -->
            <!-- <ref xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <!--<constraintSpec ident="abstractModel-p" scheme="schematron">
                                    <constraint>
                                          <report xmlns="http://purl.oclc.org/dsdl/schematron" xmlns:tei="http://www.tei-c.org/ns/1.0" 
                                                test="not(ancestor::floatingText) and (ancestor::tei:p or ancestor::tei:ab) 
                                                and not(parent::tei:exemplum
                                                |parent::tei:item
                                                |parent::tei:note
                                                |parent::tei:q
                                                |parent::tei:quote
                                                |parent::tei:remarks
                                                |parent::tei:said
                                                |parent::tei:sp
                                                |parent::tei:stage
                                                |parent::tei:cell
                                                |parent::tei:figure
                                                )">
                                                Abstract model violation: Paragraphs may not contain other paragraphs or ab elements.
                                          </report>
                                    </constraint>
                              </constraintSpec>-->
          <!--<constraintSpec ident="abstractModel-structure-l" scheme="schematron">
                                    <constraint>
                                          <report xmlns="http://purl.oclc.org/dsdl/schematron" xmlns:tei="http://www.tei-c.org/ns/1.0" test="ancestor::tei:l[not(.//tei:note//tei:p[. = current()])]">
                                                Abstract model violation: Lines may not contain higher-level structural elements such as div, p, or ab.
                                          </report>
                                    </constraint>
                              </constraintSpec>-->
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 1
              (Fernand Lucien Jules Melchior Chatin, 31 juillet 1914) », dans <title>Testaments de
                guerre de Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
              nationale des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Avant de partir à la guerre dont<lb/>
                tant ne reviendront pas, je tiens à décider<lb/> ce qui suit<choice><orig> :
                    </orig><reg>.</reg></choice></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COPA" type="div2"/>
            <ptr target="#DRPAL" type="div2"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="choice" mode="replace">
          <gloss versionDate="2009-01-06">choix</gloss>
          <desc versionDate="2009-01-06">regroupe un certain nombre de balisages alternatifs
            possibles pour un même endroit dans un texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : regroupe, soit un élément
              <gi>abbr</gi> et un élément <gi>expan</gi> (pour transcrire une abréviation telle
            quelle et la forme développée de l'expression abrégée), soit un élément <gi>sic</gi> et
            un élément <gi>corr</gi> (pour transcrire une faute de français et une proposition de
            correction de cette faute), soit un élément <gi>orig</gi> et un élément <gi>reg</gi>
            (pour transcrire une graphie ou une ponctuation ancienne et une proposition de graphie
            ou de ponctuation normalisée).</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.editorial"/>
            <memberOf key="model.linePart"/>
          </classes>
          <content>
            <alternate>
              <!--<classRef key="model.choicePart"/>
                                          <elementRef key="choice"/>-->
              <sequence>
                <elementRef key="abbr"/>
                <elementRef key="expan"/>
              </sequence>
              <sequence>
                <elementRef key="sic"/>
                <elementRef key="corr"/>
              </sequence>
              <sequence>
                <elementRef key="orig"/>
                <elementRef key="reg"/>
              </sequence>
            </alternate>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Je lègue à mon cher frère
                    <choice><abbr>M.</abbr><expan>M<ex>onsieur</ex></expan></choice> André<lb/>
                Victor Chatin <!-- [...] --></p></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"
                  ><p><choice><orig>A</orig><reg>À</reg></choice> défaut de l’un et de l’autre<lb/>
                des époux <!-- [...] --></p></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p><choice><orig>-
                  A</orig><reg>À</reg></choice> la veille de partir à la guerre<choice><orig> -
                    </orig><reg>,</reg></choice> voici mes dernières<lb/>
                <choice><sic>volonté</sic><corr>volontés</corr></choice> en cas de
                    mort<choice><orig> - </orig><reg>.</reg></choice></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COED" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="sic" mode="replace">
          <gloss versionDate="2009-03-17">du latin, <gloss>ainsi</gloss></gloss>
          <desc versionDate="2009-01-06">contient du texte reproduit quoiqu'il est apparemment
            incorrect ou inexact</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient la transcription, telle
            quelle, d'une faute de français (orthographe ou syntaxe) dans le texte transcrit. Une
            proposition de correction de cette faute doit suivre dans l'élément
            <gi>corr</gi>.</desc>
          <!--<classes>
                                    <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>
                                    <memberOf key="model.choicePart"/>
                              </classes>
                              <content>
                                    <!-\-    <rng:ref xmlns:rng="http://relaxng.org/ns/structure/1.0"
            name="macro.specialPara"/>-\->
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <classes>
            <!-- <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>-->
            <memberOf key="model.choicePart"/>
            <!--   <memberOf key="att.editLike"/>
                                    <memberOf key="att.typed"/>-->
          </classes>
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="hi"/>
              <elementRef key="damage"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="gap"/>
              <elementRef key="surplus"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifSicThenCorr" scheme="schematron">
            <constraint><sch:rule context="tei:sic"><sch:assert test="parent::tei:choice/tei:corr"
                  >Si une faute de français est transcrite, alors une proposition de correction doit
                  être encodée dans l'élément corr</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Ceci est <choice><sic>mais dernières
                    </sic><corr>ma dernière </corr></choice><lb/> volonté, en cas de
                décès.<!-- [...] --></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COEDCOR" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="corr" mode="replace">
          <gloss>correction</gloss>
          <desc versionDate="2007-06-12">contient la forme correcte d'un passage qui est considéré
            erroné dans la copie du texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient une proposition de correction
            d'une faute d'orthogaphe ou de syntaxe dans le texte transcrit. La faute doit au
            préalable avoir été encodée dans l'élément <gi>sic</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>-->
            <memberOf key="model.choicePart"/>
            <!--   <memberOf key="att.editLike"/>
                                    <memberOf key="att.typed"/>-->
          </classes>
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <!-- <elementRef key="hi"/>-->
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifCorrThenSic" scheme="schematron">
            <constraint><sch:rule context="tei:corr"><sch:assert test="parent::tei:choice/tei:sic"
                  >Si une proposition de correction de faute est donnée, alors la faute doit être
                  encodée dans l'élément sic</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!--  <constraintSpec ident="ifAttrRespOnCorrThenInternalPointer"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:corr/@resp"><sch:assert
                                                  test="starts-with(tokenize(., ' '), '#')">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a proposé
                                                  la forme corrigée du mot ou de l'expression. S'il
                                                  y a plusieurs contributeurs, taper une espace
                                                  entre chaque
                                          référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament et en particulier, en
                l'occurrence, à la saisie de la forme corrigée, telles que déclarées dans un des
                éléments <gi>respStmt</gi> de <gi>teiHeader</gi>.</valDesc>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Ceci est <choice><sic>mais dernières
                    </sic><corr>ma dernière </corr></choice><lb/> volonté, en cas de
                décès.<!-- [...] --></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COEDCOR" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="abbr" mode="replace">
          <gloss versionDate="2009-01-06">abréviation</gloss>
          <desc versionDate="2009-01-06">contient une abréviation quelconque.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient la transcription, telle
            quelle, d'un mot dont une ou plusieurs parties sont abrégées. Une proposition du mot
            dans sa forme développée doit suivre dans l'élément <gi>expan</gi>.</desc>
          <!-- <classes>
                                    <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.editorial"/>
                                    <memberOf key="model.choicePart"/>
                                    <memberOf key="att.typed"/>
                              </classes>
                              <content>
                                    <macroRef key="macro.phraseSeq"/>
                              </content>-->
          <classes>
            <memberOf key="model.choicePart"/>
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="supplied"/>
              <elementRef key="unclear"/>
              <elementRef key="damage"/>
              <elementRef key="hi"/>
              <elementRef key="gap"/>
            </alternate>
          </content>
          <constraintSpec ident="ifAbbrThenExpan" scheme="schematron">
            <constraint><sch:rule context="tei:abbr"><sch:assert test="parent::tei:choice/tei:expan"
                  >Si un mot abrégé est rencontré dans le texte du testament, une fois ce mot
                  transcrit tel quel dans l'élément abbr, il convient d'en fournir une forme
                  développée dans l'élément expan</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="rec">
              <gloss>type</gloss>
              <desc versionDate="2009-01-06">permet à l'éditeur de caractériser l'abréviation selon
                une typologie adéquate</desc>
              <datatype>
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="open">
                <valItem ident="suspension">
                  <gloss versionDate="2017-06-25">suspension</gloss>
                  <desc versionDate="2008-03-30">l'abréviation donne la première lettre du mot ou de
                    l'expression et omet le reste.</desc>
                </valItem>
                <valItem ident="contraction">
                  <gloss versionDate="2017-06-25">contraction</gloss>
                  <desc versionDate="2008-03-30">l'abréviation omet une ou plusieurs lettres au
                    milieu.</desc>
                </valItem>
                <valItem ident="brevigraph">
                  <gloss>brévigraphe</gloss>
                  <desc versionDate="2008-03-30">l'abréviation comprend un symbole spécial ou une
                    marque.</desc>
                </valItem>
                <valItem ident="superscription">
                  <gloss versionDate="2017-06-25">exposant</gloss>
                  <desc versionDate="2008-03-30">l'abréviation inclut du texte écrit au-dessus de la
                    ligne.</desc>
                </valItem>
                <valItem ident="acronym">
                  <gloss versionDate="2017-06-25">acronyme</gloss>
                  <desc versionDate="2008-03-30">l'abréviation comprend les initiales des mots d'une
                    expression.</desc>
                </valItem>
                <valItem ident="title">
                  <gloss versionDate="2017-06-25">titre</gloss>
                  <desc versionDate="2008-03-30">l'abréviation dénote une identité sociale (Dr.,
                    Mme, M., …)</desc>
                </valItem>
                <valItem ident="organization">
                  <gloss versionDate="2017-06-25">sigle</gloss>
                  <desc versionDate="2008-03-30"> l'abréviation concerne le nom d'un
                    organisme.</desc>
                </valItem>
                <valItem ident="geographic">
                  <gloss versionDate="2017-06-25">géographique</gloss>
                  <desc versionDate="2008-03-30">l'abréviation concerne un nom géographique.</desc>
                </valItem>
              </valList>
              <exemplum>
                <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="right"><choice><abbr
                        type="superscription">S.<hi rend="sup">t</hi>
                          Mandé</abbr><expan>S<ex>ain</ex>t-Mandé</expan></choice><choice><reg>,</reg><orig/></choice>
                    le deux août 1914.</dateline></egXML>
              </exemplum>
              <!--   <remarks xml:lang="fr" versionDate="2007-06-12">
                                                <p>L'attribut <att>type</att> est donné si on souhaite typer les abréviations à l'endroit où
                                                      elles apparaissent ; cela peut être utile dans certaines circonstances bien qu'une
                                                      abréviation conserve la même signification dans toutes ses occurrences. Comme les
                                                      échantillons des valeurs le montrent, les abréviations peuvent être typées selon la
                                                      méthode utilisée pour leur construction, pour leur écriture, ou le référent du terme
                                                      abrégé ; la typologie utilisée dépend de l'encodeur et doit être pensée soigneusement afin
                                                      de correspondre aux attentes. Pour une typologie des abréviations concernant le Moyen
                                                      Anglais, voir <ptr target="#PETTY"/>. </p>
                                          </remarks>-->
            </attDef>
          </attList>
          <listRef>
            <ptr target="#CONAAB" type="div2"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="expan" mode="replace">
          <gloss versionDate="2009-01-06">expansion</gloss>
          <desc versionDate="2009-01-06">contient l'expansion d'une abréviation.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient la forme développée du mot
            dont le testament donne une forme abrégée. La forme abrégée du mot doit précéder, dans
            l'élément <gi>abbr</gi>.</desc>
          <classes>
            <!--   <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.editorial"/>-->
            <memberOf key="model.choicePart"/>
            <!--  <memberOf key="att.editLike"/>-->
          </classes>
          <!--   <content>
                                    <macroRef key="macro.phraseSeq"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="ex"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifExpanThenAbbr" scheme="schematron">
            <constraint><sch:rule context="tei:expan"><sch:assert test="parent::tei:choice/tei:abbr"
                  >Si la forme développée d'un mot abrégé dans le texte du testament est donnée,
                  alors la forme abrégée de ce mot doit être encodée dans l'élément
                  abbr</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!--  <constraintSpec ident="ifAttrRespOnExpanThenInternalPointer"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:expan/@resp"><sch:assert
                                                  test="starts-with(tokenize(., ' '), '#')">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a proposé
                                                  la forme développée du mot ou de l'expression.
                                                  S'il y a plusieurs contributeurs, taper une espace
                                                  entre chaque
                                          référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament, et en particulier, en
                l'occurrence, à l'identification et à la saisie de la forme développée de
                l'abréviation, telles que déclarées dans un des éléments <gi>respStmt</gi> de
                  <gi>teiHeader</gi>.</valDesc>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="right"><choice><abbr
                    type="superscription">S.<hi rend="sup">t</hi>
                    Mandé</abbr><expan>S<ex>ain</ex>t-Mandé</expan></choice><choice><reg>,</reg><orig/></choice>
                le deux août 1914.</dateline></egXML>
          </exemplum>
          <!-- <remarks>
            <p>En général, le contenu de cet élément doit être une expression ou un mot complet.
              L'élément <gi>ex</gi> fourni par le module <ident type="module">transcr</ident> peut
              être utilisé pour baliser des suites de lettres données dans une expansion de ce
              type.</p>
          </remarks>-->
          <listRef>
            <ptr target="#CONAAB" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="orig" mode="replace">
          <gloss versionDate="2009-01-06">forme originale</gloss>
          <desc versionDate="2009-01-06">contient une partie notée comme étant fidèle à l'original
            et non pas normalisée ou corrigée.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient, telle quelle, un mot, une
            expression ou une partie de phrase du testament dans une forme ancienne non conforme à
            la forme actuelle (ponctuation non conforme aux règles actuelles, emploi non normalisé
            des majuscules, absence de diacritiques ou présence non normative de diacritiques,
            graphie syntaxiquement correcte mais ancienne). Une proposition de forme normalisée du
            mot ou de l'expression concernés doit suivre dans l'élément <gi>reg</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>-->
            <memberOf key="model.choicePart"/>
          </classes>
          <!-- <content>
                                    <!-\-    <rng:ref xmlns:rng="http://relaxng.org/ns/structure/1.0"
            name="macro.phraseSeq"/>-\->
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="pc"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="hi"/>
              <elementRef key="damage"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="gap"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifOrigThenReg" scheme="schematron">
            <constraint><sch:rule context="tei:orig"><sch:assert test="parent::tei:choice/tei:reg"
                  >Si une forme ancienne est transcrite, alors une proposition de forme conforme au
                  français actuel doit être encodée dans l'élément
              reg</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>La <choice><reg>boîte
                    bleue</reg><orig>Boîte Bleue</orig></choice> se trouvant<lb/> dans le tiroir de
                droite de<lb/> mon <choice><reg>bureau</reg><orig>Bureau</orig></choice> en
                    haut<choice><reg>,</reg><orig/></choice> ainsi<lb/> que le paquet de cartes
                enveloppées<lb/> d’un papier blanc seront<lb/> complètement
                    brûlés<choice><reg>.</reg><orig> - </orig></choice>
              </p></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline><choice><orig>Lons le
                    Saunier</orig><reg>Lons-le-Saunier</reg></choice><choice><orig/><reg>,</reg></choice>
                le 2 <choice><orig>Août</orig><reg>août</reg></choice> 1914</dateline></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COEDREG" type="div2"/>
            <ptr target="#TC" type="div1"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="reg" mode="replace">
          <gloss versionDate="2009-01-06">régularisation</gloss>
          <desc versionDate="2009-01-06">contient une partie (de texte) qui a été régularisée ou
            normalisée de façon quelconque</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : contient la forme normalisée du mot
            dont le testament donne une forme ancienne ou non conforme aux règles du français
            contemporain. La forme du mot telle que trouvée dans le texte du testament doit
            précéder, dans l'élément <gi>orig</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>-->
            <memberOf key="model.choicePart"/>
            <!-- <memberOf key="att.editLike"/>
                                    <memberOf key="att.typed"/>-->
          </classes>
          <!-- <content>
                                    <!-\-    <rng:ref xmlns:rng="http://relaxng.org/ns/structure/1.0"
            name="macro.phraseSeq"/> -\->
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifRegThenOrig" scheme="schematron">
            <constraint><sch:rule context="tei:reg"><sch:assert test="parent::tei:choice/tei:orig"
                  >Si la forme normalisée d'un mot ou d'une expression trouvés dans le texte du
                  testament est donnée, alors la forme d'origine, telle que trouvée dans le
                  testament, doit être encodée dans l'élément
              orig</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!-- <constraintSpec ident="ifAttrRespOnRegThenInternalPointer"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:reg/@resp"><sch:assert
                                                  test="starts-with(tokenize(., ' '), '#')">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a proposé
                                                  la forme normalisée du mot ou de l'expression.
                                                  S'il y a plusieurs contributeurs, taper une espace
                                                  entre chaque
                                          référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament et en particulier, en
                l'occurrence, à la saisie de la forme normalisée, telles que déclarées dans un des
                éléments <gi>respStmt</gi> de <gi>teiHeader</gi>.</valDesc>
            </attDef>
          </attList>
          <listRef>
            <ptr target="#COEDREG" type="div1"/>
            <ptr target="#TC" type="div1"/>
          </listRef>
        </elementSpec>
        <elementSpec module="transcr" ident="damage" mode="replace">
          <gloss versionDate="2007-06-12">dommage</gloss>
          <desc versionDate="2007-06-12">sert à encoder une zone qui a subi des dommages dans le
            manuscrit témoin du texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé lorsque le support a subi des
            dégâts matériels (taches, traces de fumée, de frottements, déchirures...) qui rendent la
            lecture du texte plus ou moins incertaine, jusqu'à parfois le faire disparaître en tout
            ou en partie. Souvent, on utilise dans cet élément <gi>damage</gi> un élément
              <gi>unclear</gi> ou <gi>supplied</gi>, voire un élément <gi>gap</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <memberOf key="model.linePart"/>
            <!--<memberOf key="att.typed"/>-->
            <!--<memberOf key="att.damaged"/>-->
          </classes>
          <!-- <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>
                             -->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="choice"/>
              <elementRef key="seg"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="gap"/>
              <elementRef key="ref"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifAttrUnitOnDamageThenAttrQuantity" scheme="schematron">
            <constraint><sch:rule context="tei:damage"><sch:assert
                  test="not(@quantity) or (@quantity and @unit)">Si vous avez spécifié une mesure de
                  la zone endommagée, il convient de fournir l'unité de mesure dans l'attribut
                  unit.</sch:assert><sch:assert test="not(@unit) or (@unit and @quantity)">Si vous
                  avez spécifié une unité de mesure de la zone endommagée, il convient de fournir
                  cette mesure dans l'attribut quantity.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!-- <constraintSpec ident="ifAttrQuantityOnDamageThenAttrUnit"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:damage"><sch:assert
                                                  test="if (@quantity) then (@unit) else()">Si vous
                                                  avez spécifié une mesure de la zone endommagée, il
                                                  convient de fournir l'unité de mesure dans
                                                  l'attribut
                                          unit.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <constraintSpec ident="ifDamageThenAttrAgentRecommended" scheme="schematron">
            <constraint><sch:rule context="tei:damage"><sch:assert test="@agent">Si vous utilisez
                  l'élément damage, vous devriez préciser quel agent est à l'origine de ce dommage,
                  via l'attribut agent.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="unit" usage="opt">
              <valList type="closed">
                <valItem ident="cm">
                  <gloss>cm</gloss>
                </valItem>
                <valItem ident="chars">
                  <gloss>caractères</gloss>
                </valItem>
                <valItem ident="lines">
                  <gloss>lignes</gloss>
                </valItem>
                <valItem ident="words">
                  <gloss>mots</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="quantity" usage="opt">
              <desc>le nombre de cm, de caractères, de mots ou de lignes, selon l'unité choisie,
                concernés par le dommage</desc>
              <datatype>
                <dataRef key="teidata.numeric"/>
              </datatype>
            </attDef>
            <attDef ident="agent" usage="rec">
              <desc>caractérise la cause du dommage</desc>
              <valList type="closed">
                <valItem ident="smoke">
                  <desc>traces de fumée</desc>
                </valItem>
                <valItem ident="rubbing">
                  <desc>frottements subis par le support</desc>
                </valItem>
                <valItem ident="stain">
                  <desc>tache</desc>
                </valItem>
                <valItem ident="tear">
                  <desc>déchirure</desc>
                </valItem>
                <valItem ident="dirt">
                  <desc>poussière</desc>
                </valItem>
                <valItem ident="unknown">
                  <desc>agent inconnu</desc>
                </valItem>
                <valItem ident="other">
                  <desc>autre agent</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Testament <damage agent="stain"
                    ><unclear>de</unclear></damage>
                <choice><expan>M<ex>onsieur</ex></expan><abbr type="obsolete">M<hi
                      rend="supUnderlined">r</hi></abbr></choice>
                <persName ref="#EGrandjean"> Emile Jean Léon<lb/> Grandjean</persName>
                <!-- [...] --></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHDA"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="gap" mode="replace">
          <gloss>texte non transcrit</gloss>
          <desc versionDate="2007-06-12">indique une omission dans une transcription, soit pour des
            raisons éditoriales décrites dans l'en-tête TEI au cours d’un échantillonnage, soit
            parce que le matériau est illisible ou inaudible.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé soit dans les cas rares où, un
            dommage matériel étant survenu, une partie du texte du testament est devenue totalement
            illisible ou est absente, soit dans le cas où la lecture du mot ou de l'expression est
            jugée impossible (fil de couture masquant les caractères, rature, écriture non
            déchiffrable...), ce sans qu'on puisse fournir une proposition de texte palliant la
            lacune. Dans le premier cas, l'élément <gi>gap</gi> sera utilisé dans l'élément
              <gi>damage</gi>. Dans le cas où la lecture est possible mais incertaine, on utilise
              <gi>unclear</gi>. Si la lecture est impossible, mais qu'on peut proposer un texte
            comblant la lacune, on utilise l'élément <gi>supplied</gi>.</desc>
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <memberOf key="model.global.edit"/>
            <!-- <memberOf key="att.timed"/>
                                    <memberOf key="att.editLike"/>-->
          </classes>
          <!--  <content>
                                    <alternate minOccurs="0" maxOccurs="unbounded">
                                          <classRef key="model.descLike"/>
                                          <classRef key="model.certLike"/>
                                    </alternate>
                              </content>-->
          <content>
            <!-- <!-\-<macroRef key="macro.paraContent"/>-\->
                                    <alternate minOccurs="0" maxOccurs="unbounded">
                                          <textNode/>
                                          <!-\-<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-\->
                                          <elementRef key="lb"/>
                                          <elementRef key="pb"/>
                                          <elementRef key="hi"/>
                                          <!-\-  <elementRef key="choice"/>
                                          <elementRef key="app"/>-\->
                                         
                                         
                                          <!-\- <classRef key="model.pPart.transcriptional"/>-\->
                                          <!-\-  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-\->
                                    </alternate>-->
            <empty/>
          </content>
          <constraintSpec ident="ifGapThenAttrReasonRecommended" scheme="schematron">
            <constraint><sch:rule context="tei:gap"><sch:assert test="@reason">Si vous utilisez
                  l'élément gap, vous devriez préciser pour quelle raison vous ne pouvez transcrire
                  la partie du texte ainsi désignée, via l'attribut
              reason.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="ifAttrUnitOnGapThenAttrQuantity" scheme="schematron">
            <constraint><sch:rule context="tei:gap"><sch:assert
                  test="not(@unit) or (@unit and @quantity)">Si vous avez spécifié une unité de
                  mesure de la zone non transcrite, il convient de fournir cette mesure dans
                  l'attribut quantity.</sch:assert><sch:assert
                  test="not(@quantity) or (@quantity and @unit)">Si vous avez spécifié une mesure de
                  la zone non transcrite, il convient de fournir l'unité de mesure dans l'attribut
                  unit.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!-- <constraintSpec ident="ifAttrQuantityOnGapThenAttrUnit"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:gap"><sch:assert
                                                  test="if (@quantity) then (@unit) else()">Si vous
                                                  avez spécifié une mesure de la zone non
                                                  transcrite, il convient de fournir l'unité de
                                                  mesure dans l'attribut
                                                unit.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <attDef ident="reason" usage="rec">
              <gloss>raison</gloss>
              <desc versionDate="2017-02-06">donne la raison de l'omission</desc>
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="semi">
                <valItem ident="cancelled">
                  <gloss versionDate="2017-02-06">biffé, devenu illisible</gloss>
                </valItem>
                <valItem ident="deleted">
                  <gloss>détruit, absent</gloss>
                </valItem>
                <!-- <valItem ident="editorial">
                                                      <desc versionDate="2017-02-06" xml:lang="en">for features omitted from
                                                            transcription due to editorial policy</desc>
                                                      <desc versionDate="2017-02-07" xml:lang="de">für Bestandteile, 
                                                            die aus editorischen Gründen nicht übertragen wurden</desc>
                                                </valItem>-->
                <valItem ident="illegible">
                  <gloss versionDate="2017-02-06">non déchiffré</gloss>
                </valItem>
                <valItem ident="hidden">
                  <gloss>masqué (par le fil de couture, par une tache...)</gloss>
                </valItem>
                <!--   <valItem ident="inaudible">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">nicht hörbar</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">incomprensibile</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">inaudible</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">inaudible</gloss>
                                                </valItem>-->
                <!--  <valItem ident="irrelevant">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">irrelevant</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">irrilevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">irrelevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">non pertinent</gloss>
                                                </valItem>-->
                <!-- <valItem ident="sampling">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">Auswahl</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">campionatura</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">ejemplificación</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">échantillonnage</gloss>
                                                </valItem>-->
              </valList>
            </attDef>
            <attDef ident="unit" usage="opt">
              <valList type="closed">
                <valItem ident="cm">
                  <gloss>cm</gloss>
                </valItem>
                <valItem ident="chars">
                  <gloss>caractères</gloss>
                </valItem>
                <valItem ident="lines">
                  <gloss>lignes</gloss>
                </valItem>
                <valItem ident="words">
                  <gloss>mots</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="quantity" usage="opt">
              <desc>le nombre de cm, de caractères, de lignes ou de mots, selon l'unité choisie,
                concernés par la lacune dans la transcription</desc>
              <datatype>
                <dataRef key="teidata.numeric"/>
              </datatype>
            </attDef>
          </attList>
          <listRef>
            <ptr target="#COEDADD" type="div1"/>
          </listRef>
        </elementSpec>
        <elementSpec module="transcr" ident="supplied" mode="replace">
          <gloss versionDate="2009-11-16">texte restitué</gloss>
          <desc versionDate="2009-11-16">permet d'encoder du texte restitué par l'auteur de la
            transcription ou par l'éditeur pour une raison quelconque, le plus souvent parce que le
            texte du document original ne peut être lu, par suite de dommages matériels ou de
            lacunes.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé soit dans les cas rares où, un
            dommage matériel étant survenu, une partie du texte du testament est devenue illisible
            ou est absente, soit dans le cas où la lecture du mot ou de l'expression est jugée
            impossible (fil de couture masquant les caractères, rature, écriture non
            déchiffrable...), dès lors qu'on peut fournir une proposition de texte palliant la
            lacune. Dans le premier cas, l'élément <gi>supplied</gi> sera utilisé dans l'élément
              <gi>damage</gi>. Dans le cas où la lecture est possible mais incertaine, on utilise
              <gi>unclear</gi>. Si la lecture est impossible et qu'on ne peut restituer le texte, on
            utilise l'élément <gi>gap</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <!--  <memberOf key="att.editLike"/>-->
            <!--<memberOf key="model.choicePart"/>-->
          </classes>
          <!-- <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="seg"/>
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <!--<constraintSpec ident="ifAttrRespOnSuppliedThenInternalPointer"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:supplied/@resp"><sch:assert
                                                  test="starts-with(tokenize(., ' '), '#')">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a proposé
                                                  le texte restitué. S'il y a plusieurs
                                                  contributeurs, taper une espace entre chaque
                                                  référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <constraintSpec ident="ifSuppliedAloneThenAttrReasonRecommended" scheme="schematron">
            <constraint><sch:rule context="tei:supplied[not(parent::tei:damage)]"><sch:assert
                  test="@reason">Si vous utilisez l'élément supplied, vous devriez préciser pour
                  quelle raison vous devez restituer la partie du texte ainsi désignée et non
                  transcrite, via l'attribut reason.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="ifAttrUnitOnSuppliedThenAttrQuantity" scheme="schematron">
            <constraint><sch:rule context="tei:supplied"><sch:assert
                  test="not(@unit) or (@unit and @quantity)">Si vous avez spécifié une unité de
                  mesure de la zone restituée, il convient de fournir cette mesure dans l'attribut
                  quantity.</sch:assert><sch:assert test="not(@quantity) or (@quantity and @unit)"
                  >Si vous avez spécifié une mesure de la zone restituée, il convient de fournir
                  l'unité de mesure dans l'attribut unit.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!-- <constraintSpec ident="ifAttrQuantityOnSuppliedThenAttrUnit"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:supplied"><sch:assert
                                                  test="if (@quantity) then (@unit) else()">Si vous
                                                  avez spécifié une mesure de la zone restituée, il
                                                  convient de fournir l'unité de mesure dans
                                                  l'attribut
                                          unit.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <attDef ident="unit" usage="opt">
              <valList type="closed">
                <valItem ident="cm">
                  <gloss>cm</gloss>
                </valItem>
                <valItem ident="chars">
                  <gloss>caractères</gloss>
                </valItem>
                <valItem ident="lines">
                  <gloss>lignes</gloss>
                </valItem>
                <valItem ident="words">
                  <gloss>mots</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="quantity" usage="opt">
              <desc>le nombre de cm, de caractères, de mots ou de lignes, selon l'unité choisie,
                restitués par le contributeur</desc>
              <datatype>
                <dataRef key="teidata.numeric"/>
              </datatype>
            </attDef>
            <!-- <attDef ident="reason" usage="opt">
                                          
                                          
                                          <desc versionDate="2007-06-12">donne la raison pour laquelle on a dû restituer le texte.</desc>
                                          <!-\-par exemple <mentioned>reliure-serrée</mentioned>, <mentioned>encre-effacée</mentioned>,
<mentioned>feuillet-disparu</mentioned>, <mentioned>omis-sur-original</mentioned>.-\->
                                         
                                        <!-\-  <datatype maxOccurs="unbounded"><dataRef key="teidata.word"/></datatype>-\->
                                    </attDef>-->
            <attDef ident="reason" usage="rec">
              <gloss>raison</gloss>
              <desc>donne la raison pour laquelle on a du restituer le texte</desc>
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="semi">
                <valItem ident="cancelled">
                  <gloss versionDate="2017-02-06">biffé, devenu illisible</gloss>
                </valItem>
                <valItem ident="deleted">
                  <gloss>détruit, absent</gloss>
                </valItem>
                <!-- <valItem ident="editorial">
                                                      <desc versionDate="2017-02-06" xml:lang="en">for features omitted from
                                                            transcription due to editorial policy</desc>
                                                      <desc versionDate="2017-02-07" xml:lang="de">für Bestandteile, 
                                                            die aus editorischen Gründen nicht übertragen wurden</desc>
                                                </valItem>-->
                <valItem ident="illegible">
                  <gloss versionDate="2017-02-06">non déchiffré</gloss>
                </valItem>
                <valItem ident="hidden">
                  <gloss>masqué (par le fil de couture, par une tache...)</gloss>
                </valItem>
                <!--   <valItem ident="inaudible">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">nicht hörbar</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">incomprensibile</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">inaudible</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">inaudible</gloss>
                                                </valItem>-->
                <!--  <valItem ident="irrelevant">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">irrelevant</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">irrilevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">irrelevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">non pertinent</gloss>
                                                </valItem>-->
                <!-- <valItem ident="sampling">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">Auswahl</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">campionatura</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">ejemplificación</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">échantillonnage</gloss>
                                                </valItem>-->
              </valList>
            </attDef>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament (et en particulier, en
                l'occurrence, à la saisie d'une portion de texte restituée), telles que déclarées
                dans un des éléments <gi>respStmt</gi> de <gi>teiHeader</gi>.</valDesc>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Pour le reste de mes biens mon
                  <damage agent="stain"><supplied>frère</supplied></damage><lb/> André, dont je
                connais l’esprit de<lb/> sagesse et de bon sens, les reçoit en<lb/> pleine
                propriété. Puisse-t-il en<lb/> jouir longtemps et heureux !</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHDA"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="unclear" mode="replace">
          <gloss versionDate="2009-01-06">transcription incertaine</gloss>
          <desc versionDate="2009-01-06">contient un mot, une expression ou bien un passage qui ne
            peut être transcrit avec certitude parce qu'il est illisible ou inaudible dans la
            source.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé lorsque la transcription
            proposée est incertaine, dans les cas rares où un dommage matériel est survenu, ou bien
            lorsque l'écriture est difficile à déchiffrer, ou encore si une rature ou un fil de
            couture masquent partiellement le texte. Dans le premier cas, l'élément <gi>unclear</gi>
            sera utilisé dans l'élément <gi>damage</gi>. Dans le cas où la lecture est totalement
            impossible mais qu'on peut proposer une restitution du texte, on utilise
              <gi>supplied</gi>. Si la lecture est impossible et qu'on ne peut restituer le texte,
            on utilise l'élément <gi>gap</gi>.</desc>
          <classes>
            <!--<memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <memberOf key="model.linePart"/>
            <!-- <memberOf key="model.choicePart"/>-->
            <!--  <memberOf key="att.editLike"/>-->
          </classes>
          <!-- <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <elementRef key="seg"/>
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <constraintSpec ident="ifUnclearAloneThenAttrReasonRecommended" scheme="schematron">
            <constraint><sch:rule context="tei:unclear[not(parent::tei:damage)]"><sch:assert
                  test="@reason">Si vous utilisez l'élément unclear, vous devriez préciser pour
                  quelle raison vous jugez la transcription incertaine, via l'attribut
                  reason.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!--<constraintSpec ident="ifAttrRespOnUnclearThenInternalPointer"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:unclear/@resp"><sch:assert
                                                  test="starts-with(tokenize(., ' '), '#')">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a proposé
                                                  la transcription incertaine. S'il y a plusieurs
                                                  contributeurs, taper une espace entre chaque
                                                  référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <attList>
            <!-- <attDef ident="reason" usage="opt">
                                          
                                          
                                          <desc versionDate="2007-06-12">donne la raison pour laquelle on a dû restituer le texte.</desc>
                                          <!-\-par exemple <mentioned>reliure-serrée</mentioned>, <mentioned>encre-effacée</mentioned>,
<mentioned>feuillet-disparu</mentioned>, <mentioned>omis-sur-original</mentioned>.-\->
                                         
                                        <!-\-  <datatype maxOccurs="unbounded"><dataRef key="teidata.word"/></datatype>-\->
                                    </attDef>-->
            <attDef ident="reason" usage="rec">
              <gloss>raison</gloss>
              <desc versionDate="2009-01-06">indique pourquoi il est difficile de transcrire le
                texte</desc>
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="semi">
                <valItem ident="cancelled">
                  <gloss versionDate="2017-02-06">biffé</gloss>
                </valItem>
                <!-- <valItem ident="editorial">
                                                      <desc versionDate="2017-02-06" xml:lang="en">for features omitted from
                                                            transcription due to editorial policy</desc>
                                                      <desc versionDate="2017-02-07" xml:lang="de">für Bestandteile, 
                                                            die aus editorischen Gründen nicht übertragen wurden</desc>
                                                </valItem>-->
                <valItem ident="quite-illegible">
                  <gloss versionDate="2017-02-06">difficile à déchiffrer</gloss>
                </valItem>
                <valItem ident="hidden">
                  <gloss>masqué (par le fil de couture, par une tache...)</gloss>
                </valItem>
                <!--   <valItem ident="inaudible">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">nicht hörbar</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">incomprensibile</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">inaudible</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">inaudible</gloss>
                                                </valItem>-->
                <!--  <valItem ident="irrelevant">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">irrelevant</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">irrilevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">irrelevante</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">non pertinent</gloss>
                                                </valItem>-->
                <!-- <valItem ident="sampling">
                                                      <gloss versionDate="2017-02-06" xml:lang="de">Auswahl</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="it">campionatura</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="es">ejemplificación</gloss>
                                                      <gloss versionDate="2017-02-06" xml:lang="fr">échantillonnage</gloss>
                                                </valItem>-->
              </valList>
            </attDef>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament (et en particulier, en
                l'occurrence, à la saisie d'une transcription incertaine), telles que déclarées dans
                un des éléments <gi>respStmt</gi> de <gi>teiHeader</gi>.</valDesc>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Pour le reste de mes biens mon
                  <damage agent="stain"><supplied>frère</supplied></damage><lb/> André, dont je
                connais <unclear reason="quite-illegible">l’esprit de</unclear><lb/> sagesse et de
                bon sens, les reçoit en<lb/> pleine propriété. Puisse-t-il en<lb/> jouir longtemps
                et heureux !</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHDA"/>
            <ptr target="#COEDADD"/>
          </listRef>
        </elementSpec>
        <elementSpec module="transcr" ident="surplus" mode="replace">
          <gloss versionDate="2007-06-12">texte superflu</gloss>
          <desc versionDate="2009-11-16">permet d'encoder une partie de texte présente dans la
            source lorsque l'éditeur la considère superflue ou redondante.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé à l'intérieur de l'élément
              <gi>sic</gi> uniquement, le plus souvent parce que le testateur a écrit deux fois le
            même mot ou la même expression.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <!-- <memberOf key="att.editLike"/>-->
          </classes>
          <!-- <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="hi"/>
              <!--  <elementRef key="choice"/>
                                          <elementRef key="app"/>-->
              <!-- <classRef key="model.pPart.transcriptional"/>-->
              <!--  <elementRef key="placeName"/>
                                          <elementRef key="date"/>-->
            </alternate>
          </content>
          <!-- <attList>
                                    <attDef ident="reason" usage="opt">
                                          <desc versionDate="2013-12-06" xml:lang="en">one or more words indicating why this text is believed to be superfluous, e.g.
                                                <mentioned>repeated</mentioned>,
                                                <mentioned>interpolated</mentioned> etc.</desc>
                                          <desc versionDate="2009-11-16" xml:lang="fr">indique les raisons pour lesquelles on considère cette partie de texte comme superflue.</desc>
                                          <datatype maxOccurs="unbounded"><dataRef key="teidata.word"/></datatype>
                                    </attDef>
                              </attList>-->
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Sain de corps et d’esprit, avant de
                partir <choice><reg/><sic><surplus>de<lb/>partir</surplus></sic><corr/></choice>
                pour la mobilisation française, j’écris sur<lb/> ce papier libre, faute d’avoir pu
                me procurer<lb/> un papier timbré, mon testament et mes<lb/> dernières
              volontés.</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHDA"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="add" mode="replace">
          <gloss versionDate="2009-01-06"> ajout</gloss>
          <desc versionDate="2009-01-06">contient des lettres, des mots ou des phrases insérés dans
            le texte par un auteur, un copiste, un annotateur ou un correcteur.</desc>
          <desc type="wills-ui"> Projet Testaments de Poilus : utilisé pour baliser les parties de
            texte ajoutées au testament, lors d'une deuxième phase d'écriture, par le testateur
            (additions interlinéaires ou marginales). De tels cas sont rares. L'addition peut
            intervenir seule, ou pour remplacer une partie de texte raturée (dans ce dernier cas,
            l'élément <gi>add</gi> sera utilisé au sein de l'élément <gi>subst</gi>, après
              <gi>del</gi>). La position du texte ajouté par rapport à la phrase ou au paragraphe
            peut être précisée à l'aide de l'attribut <att>place</att>. </desc>
          <classes>
            <!--   <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <memberOf key="model.linePart"/>
            <!-- <memberOf key="att.transcriptional"/>-->
            <!--<memberOf key="att.placement"/>-->
            <!-- <memberOf key="att.typed"/>-->
          </classes>
          <!--   <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!-- MDH 2013-11-11: per http://sourceforge.net/p/tei/feature-requests/472/ adding 
      docDate to the content model, so it now has to be explicit instead of 
      macro.phraseSeq. -->
            <!-- <ref xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="note"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <attList>
            <attDef ident="place" usage="rec">
              <gloss>emplacement</gloss>
              <desc>précise la position du texte ajouté par rapport à la phrase ou au paragraphe
                auquel il est ajouté.</desc>
              <valList type="closed">
                <valItem ident="above">
                  <gloss>au-dessus de la ligne de texte</gloss>
                </valItem>
                <valItem ident="below">
                  <gloss>au-dessous de la ligne de texte</gloss>
                </valItem>
                <valItem ident="inline">
                  <gloss>sur la ligne principale de texte</gloss>
                </valItem>
                <valItem ident="marginLeft">
                  <gloss>dans la marge de gauche</gloss>
                </valItem>
                <valItem ident="marginRight">
                  <gloss>dans la marge de droite</gloss>
                </valItem>
                <valItem ident="marginBottom">
                  <gloss>sous le texte</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="right">Fait à
                    Paris<choice><orig/><reg>,</reg></choice> en pleine <add place="inline"
                  >connaissance</add><choice><orig/><reg>,</reg></choice><lb/> le <choice><orig>Dix
                    Janvier</orig><reg>dix janvier</reg></choice> 1916.</dateline></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>En cas d’existence d’enfants ou de
                descendants d’eux<lb/> à l’époque dudit décès, cette <subst><del>dotation</del><add
                    place="above">donation</add></subst>, si la réduction<lb/> en est demandée,
                comprendra la plus forte quotité des<lb/> possibles entre époux tant en pleine
                propriété et en<lb/> usufruit desdits biens en y comprenant même tous<lb/>
                rapports.</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COEDADD" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="del" mode="replace">
          <gloss versionDate="2008-12-09">suppression</gloss>
          <desc versionDate="2007-06-12">contient une lettre, un mot ou un passage supprimé, marqué
            comme supprimé, sinon indiqué comme superflu ou erroné dans le texte par un auteur, un
            copiste, un annotateur ou un correcteur.</desc>
          <desc type="wills-ui"> Projet Testaments de Poilus : utilisé pour baliser les parties de
            texte supprimées (raturées) par le testateur. De tels cas sont rares. La suppression
            peut intervenir seule, ou être accompagnée d'un mot ou d'une expression qui remplacent
            le texte supprimé (dans ce dernier cas, l'élément <gi>del</gi> sera utilisé au sein de
            l'élément <gi>subst</gi>, avant <gi>add</gi>). </desc>
          <!--  <classes>
                                    <memberOf key="att.global"/>
                                    <memberOf key="model.pPart.transcriptional"/>
                                    <memberOf key="model.linePart"/>
                                    <memberOf key="att.transcriptional"/>
                                    <memberOf key="att.typed"/>
                              </classes>
                              <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <classes>
            <!--   <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.transcriptional"/>
            <memberOf key="model.linePart"/>
            <!-- <memberOf key="att.transcriptional"/>-->
            <!--<memberOf key="att.placement"/>-->
            <!-- <memberOf key="att.typed"/>-->
          </classes>
          <!--   <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!-- MDH 2013-11-11: per http://sourceforge.net/p/tei/feature-requests/472/ adding 
      docDate to the content model, so it now has to be explicit instead of 
      macro.phraseSeq. -->
            <!-- <ref xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Je <del>donne</del> désire que M.
                Lucien Rotgès,<lb/> demeurant à Orléans, 244 rue du Faubourg-Saint-Vincent<lb/> soit
                doté d’une rente mensuelle<lb/> et viagère de <del>2000 fr</del>200
              francs.</p></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>En cas d’existence d’enfants ou de
                descendants d’eux<lb/> à l’époque dudit décès, cette <subst><del>dotation</del><add
                    place="above">donation</add></subst>, si la réduction<lb/> en est demandée,
                comprendra la plus forte quotité des<lb/> possibles entre époux tant en pleine
                propriété et en<lb/> usufruit desdits biens en y comprenant même tous<lb/>
                rapports.</p></egXML>
          </exemplum>
          <remarks>
            <p>Le texte supprimé doit être au moins partiellement lisible, afin que l'encodeur soit
              en mesure de le transcrire. La partie illisible du texte à l'intérieur d'une
              suppression peut être marquée au moyen de la balise <gi>gap</gi> pour signaler la
              présence de texte non transcrit. La quantité de texte omise, la raison de l'omission,
              etc., peuvent être indiquées au moyen des attributs de l'élément <gi>gap</gi>. Si le
              texte n'est pas entièrement lisible, l'élément <gi>unclear</gi> (disponible avec le
              jeu additionnel de balises pour la transcription des sources primaires) doit être
              utilisé pour signaler les zones de texte ne pouvant pas être lues de manière fiable.
            </p>
          </remarks>
          <listRef>
            <ptr target="#COEDADD" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="transcr" ident="subst" mode="replace">
          <gloss versionDate="2008-10-02"> substitution</gloss>
          <desc versionDate="2009-11-16">regroupe une ou plusieurs parties de texte supprimées et
            une ou plusieurs parties de texte ajoutées, lorsque cette combinaison peut être
            considérée comme une intervention unique sur le texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé pour regrouper un élément
              <gi>del</gi> et un élément <gi>add</gi> lorsque le texte ajouté se substitue au texte
            supprimé.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.pPart.editorial"/>
            <!--  <memberOf key="att.transcriptional"/>-->
          </classes>
          <content>
            <sequence>
              <elementRef key="del"/>
              <elementRef key="add"/>
            </sequence>
            <!--  <alternate minOccurs="1" maxOccurs="unbounded">-->
            <!--<classRef key="model.milestoneLike"/>-->
            <!--</alternate>-->
          </content>
          <!-- <constraintSpec ident="substContents1" scheme="schematron">
                                    <constraint>
                                          <assert xmlns="http://purl.oclc.org/dsdl/schematron" test="child::tei:add and child::tei:del"><name/> must have at least one child add and at least one child del</assert>
                                    </constraint>
                              </constraintSpec>-->
          <constraintSpec ident="ifSubstThenDelAndAdd" scheme="schematron">
            <constraint><sch:rule context="tei:subst"><sch:assert test="tei:del and tei:add">Si
                  l'élément subst est utilisé, il doit contenir un élément del suivi d'un élément
                  add</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>En cas d’existence d’enfants ou de
                descendants d’eux<lb/> à l’époque dudit décès, cette <subst><del>dotation</del><add
                    place="above">donation</add></subst>, si la réduction<lb/> en est demandée,
                comprendra la plus forte quotité des<lb/> possibles entre époux tant en pleine
                propriété et en<lb/> usufruit desdits biens en y comprenant même tous<lb/>
                rapports.</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHSU"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="hi" mode="replace">
          <gloss versionDate="2009-01-06">mis en évidence</gloss>
          <desc versionDate="2009-01-06">distingue un mot ou une expression comme graphiquement
            distincte du texte environnant, sans en donner la raison.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé pour spécifier que le
            testateur a graphiquement mis en valeur un mot (ou une expression), le plus souvent en
            le soulignant ou en l'écrivant en majuscules. Sert aussi pour baliser les lettres
            placées en exposant. Doit avoir un attribut <att>rend</att> dont la valeur est à prendre
            dans une liste fermée.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.hiLike"/>
            <!-- <memberOf key="att.written"/>-->
          </classes>
          <!--  <content>
                                    <macroRef key="macro.paraContent"/>
                              </content>-->
          <content>
            <!-- MDH 2013-11-11: per http://sourceforge.net/p/tei/feature-requests/472/ adding 
      docDate to the content model, so it now has to be explicit instead of 
      macro.phraseSeq. -->
            <!-- <ref xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <constraintSpec ident="ifHiThenAttrRend" scheme="schematron">
            <constraint><sch:rule context="tei:hi"><sch:assert test="@rend">Si vous utilisez
                  l'élément hi pour indiquer que le testateur a mis en valeur graphiquement un mot
                  ou une expression, vous devriez spécifier comment il l'a mis en valeur en
                  utilisant l'attribut rend</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="rend" usage="req">
              <gloss>rendu</gloss>
              <desc>caractérise la manière dont le mot ou l'expression balisés ont été rendus ,
                présentés, dans le texte source</desc>
              <valList type="closed">
                <valItem ident="superscript">
                  <gloss>en exposant</gloss>
                </valItem>
                <valItem ident="underlined">
                  <gloss>souligné</gloss>
                </valItem>
                <valItem ident="double-underlined">
                  <gloss>souligné deux fois</gloss>
                </valItem>
                <valItem ident="superscript-underlined">
                  <gloss>en exposant et souligné</gloss>
                </valItem>
                <valItem ident="capital-letters">
                  <gloss>en lettres majuscules</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Quant à mes livres, tous les ouvrages<lb/>
                <hi rend="underlined">de droit, exclusivement</hi>, seront, si mon<lb/> fils ne
                dirige pas ses études de ce côté,<lb/> mis à la disposition de l’ordre des
                avocats<lb/> de Paris <!-- [...] --></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COHQHE"/>
            <ptr target="#COHQH"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="lb" mode="replace">
          <gloss versionDate="2009-01-06">saut de ligne</gloss>
          <desc versionDate="2009-01-06">marque le début d'une nouvelle ligne (typographique) dans
            une édition ou dans une version d'un texte.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : à utiliser pour indiquer un changement
            de ligne dans le texte du testament. Si le changement de ligne intervient à l'intérieur
            d'un mot, ne pas taper le tiret de césure, mais utiliser l'attribut <att>break</att> en
            lui donnant la valeur "no". </desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.milestoneLike"/>
            <!--  <memberOf key="att.typed"/>
                                    <memberOf key="att.edition"/>
                                    <memberOf key="att.spanning"/>-->
            <!--<memberOf key="att.breaking"/>-->
          </classes>
          <content>
            <empty/>
          </content>
          <attList>
            <attDef ident="break" usage="opt">
              <valList type="closed">
                <valItem ident="no">
                  <gloss>non (pas de nouveau mot après le changement de ligne ; ce changement
                    intervient à l'intérieur d'un mot)</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 16
              (Jules Louis Legeay, 2 août 1914) », dans <title>Testaments de guerre de Poilus
                parisiens (1914-1918) : une édition critique</title>. Paris : École nationale des
              chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-016.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-016.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p><!-- [...] -->Je pars demain 2<hi
                  rend="sup">e</hi> jour ; pris à l’im<lb break="no"/>proviste, je n’ai plus ni le
                temps ni<lb/>les moyens de faire une donation<lb/>en règle à ma femme bien aimée.
              </p></egXML>
          </exemplum>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 1 (
              Fernand Lucien Jules Melchior Chatin, 31 juillet 1914) », dans <title>Testaments de
                guerre de Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
              nationale des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Avant de partir à la guerre dont<lb/>
                tant ne reviendront pas, je tiens à décider<lb/>ce qui suit
              <!-- [...]--></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#CORS5" type="div3"/>
            <ptr target="#DRPAL" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec ident="pb" module="core" mode="replace">
          <gloss versionDate="2009-01-06">saut de page</gloss>
          <desc versionDate="2007-06-12">marque le début d'une page de texte dans un document
            paginé.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé pour indiquer les changements
            de page dans le texte du testament. On l'utilise aussi pour indiquer la première page du
            testament. L'élément <gi>pb</gi> a obligatoirement un attribut <att>facs</att> qui
            renvoie, via son identifiant, à l'image numérique reproduisant la nouvelle page, telle
            que déclarée dans l'élément <gi>facsimile</gi>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.milestoneLike"/>
            <!-- <memberOf key="att.typed"/>-->
            <!--  <memberOf key="att.edition"/>
                                    <memberOf key="att.spanning"/>
                                    <memberOf key="att.breaking"/>-->
          </classes>
          <content>
            <empty/>
          </content>
          <constraintSpec ident="ifPbThenAttrFacs" scheme="schematron">
            <constraint><sch:rule context="tei:pb"><sch:assert
                  test="matches(@facs, '#testament-(\d\d\d\d)_vue-(\d\d)([a|b|c]*)_jpg')">L'élément
                  pb doit avoir un attribut facs renvoyant vers l'image numérique reproduisant la
                  page suivant le changement, via l'identifiant de cette image telle que déclarée
                  dans l'élément facsimile.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="facs" usage="req">
              <gloss/>
              <desc>après le caractère dièse qui indique un pointeur interne, taper l'identifiant
                (la valeur de l'attribut <att>xml:id</att> de l'élément <gi>graphic</gi>) de l'image
                numérique reproduisant la page sur laquelle on se trouve après le changement de
                page.</desc>
            </attDef>
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 1
              (Fernand Lucien Jules Melchior Chatin, 31 juillet 1914) », dans <title>Testaments de
                guerre de Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École
              nationale des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-001.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><text xml:id="will-0001">
                <body>
                  <div type="will">
                    <pb facs="#testament-0001_vue-01_jpg"/>
                    <dateline rend="centered">Paris<choice><orig/><reg>,</reg></choice> le
                          <choice><orig>trente et un</orig><reg>trente-et-un</reg></choice>
                      <choice><orig> Juillet</orig><reg> juillet</reg></choice><lb/>
                      <choice><orig>mil</orig><reg>mille</reg></choice> neuf cent quatorze<lb/> (31
                          <choice><orig>Juillet</orig><reg>juillet</reg></choice> 1914)</dateline>
                    <!-- [... etc. ] -->
                  </div>
                </body>
              </text></egXML>
          </exemplum>
          <listRef>
            <ptr target="#CORS5" type="div3"/>
          </listRef>
        </elementSpec>
        <elementSpec module="transcr" ident="space" mode="replace">
          <gloss versionDate="2007-06-12">espace</gloss>
          <desc versionDate="2009-11-16">permet de situer un espace significatif dans le texte
            édité.</desc>
          <desc type="wills-ui"> Projet Testaments de Poilus : utilisé lorsque dans le corps de son
            testament, le testateur a laissé blanc un espace significatif (le plus souvent une ou
            plusieurs lignes). Devrait toujours avoir les attributs <att>dim</att>,
              <att>quantity</att> et <att>unit</att>. </desc>
          <classes>
            <!--  <memberOf key="att.global"/>
                                    <memberOf key="att.typed"/>-->
            <memberOf key="model.global.edit"/>
            <!--  <memberOf key="att.dimensions"/>-->
          </classes>
          <content>
            <!--   <alternate minOccurs="0" maxOccurs="unbounded">
                                          <classRef key="model.descLike"/>
                                          <classRef key="model.certLike"/>
                                    </alternate>-->
            <empty/>
          </content>
          <constraintSpec ident="ifAttrUnitOnSpaceThenAttrQuantity" scheme="schematron">
            <constraint><sch:rule context="tei:space"
                  ><!--<sch:assert
                  test="if (@unit) then (@quantity) else()">Si vous avez spécifié une unité de
                  mesure de l'espace laissé blanc, il convient de fournir cette mesure dans
                  l'attribut quantity.</sch:assert>--><sch:assert
                  test="not(@quantity) or (@quantity and @unit)">Si vous avez spécifié une mesure de
                  l'espace laissé blanc, il convient de fournir l'unité de mesure dans l'attribut
                  unit.</sch:assert><sch:assert test="not(@unit) or (@unit and @quantity)">Si vous
                  avez spécifié une unité de mesure de l'espace laissé blanc, il convient de fournir
                  cette mesure dans l'attribut quantity.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!--<constraintSpec ident="ifAttrQuantityOnSpaceThenAttrUnit" scheme="schematron">
            <constraint><sch:rule context="tei:space"><sch:assert
                  test="if (@quantity) then (@unit) else()">Si vous avez spécifié une mesure de
                  l'espace laissé blanc, il convient de fournir l'unité de mesure dans l'attribut
                  unit.</sch:assert></sch:rule></constraint>
          </constraintSpec>-->
          <attList>
            <attDef ident="dim" usage="req">
              <gloss versionDate="2009-11-16">dimension</gloss>
              <desc versionDate="2009-11-16">indique si l'espace laissé blanc est vertical ou
                horizontal.</desc>
              <valList type="closed">
                <valItem ident="horizontal">
                  <desc versionDate="2009-11-16">l'espace est horizontal.</desc>
                </valItem>
                <valItem ident="vertical">
                  <desc versionDate="2009-11-16"> l'espace est vertical.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="unit" usage="rec">
              <valList type="closed">
                <valItem ident="cm">
                  <gloss>cm</gloss>
                </valItem>
                <valItem ident="lines">
                  <gloss>lignes</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="quantity" usage="rec">
              <desc>le nombre de cm, ou de lignes, selon l'unité choisie, sur lesquels s'étend
                l'espace laissé blanc par le testateur</desc>
              <datatype>
                <dataRef key="teidata.numeric"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 6
              (Joseph Bernel, 1<hi rend="superscript">er</hi> août 1914) », dans <title>Testaments
                de guerre de Poilus parisiens (1914-1918) : une édition critique</title>. Paris :
              École nationale des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-006.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-006.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"
                    ><dateline>Paris<choice><orig/><reg>,</reg></choice> le 1<hi
                  rend="superscript-underlined">er</hi>
                <choice><reg>août</reg><orig>Août</orig></choice> 1914</dateline><space
                dim="vertical" quantity="4" unit="lines"/><p>Je soussigné <persName ref="#JBernel"
                  >Joseph <surname>Bernel</surname></persName><lb/> déclare donner tout ce que
                je<lb/> possède à ma femme Madame<lb/>
                <!-- [...] --></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PHSP"/>
          </listRef>
        </elementSpec>
        <elementSpec ident="metamark" module="transcr" mode="replace">
          <gloss versionDate="2017-07-27">métamarque</gloss>
          <desc versionDate="2017-07-27">contient ou décrit tout type de signe graphique ou de
            caractère dans un document dont la fonction est de déterminer comment le document
            devrait être lu (ce signe ne fait donc pas partie du contenu proprement dit du
            document).</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : cet élément est utilisé lorsqu'on
            souhaite spécifier que le testateur a inscrit un signe ou un dessin (le plus souvent une
            ligne ou une croix) ayant un rôle dans la lecture du testament (le plus souvent, cette
            marque a été posée pour mettre en évidence un passage ou pour séparer deux parties du
            testament). Cet élément devrait avoir les attributs <att>function</att> et
              <att>rend</att>.</desc>
          <classes>
            <memberOf key="model.global"/>
            <!-- was pPart.transcriptional-->
            <!-- <memberOf key="att.spanning"/>
                                    <memberOf key="att.placement"/>
                                    <memberOf key="att.global"/>-->
          </classes>
          <content>
            <!-- <macroRef key="macro.specialPara"/>-->
            <empty/>
          </content>
          <constraintSpec ident="ifMetamarkThenAttrsFunctionAndRend" scheme="schematron">
            <constraint><sch:rule context="tei:metamark"><sch:assert test="@function and @rend">Si
                  vous utilisez l'élément metamark, vous devriez indiquer quelle fonction a la
                  métamarque (en utilisant l'attribut function) et quelle forme elle prend ((en
                  utilisant l'attribut rend)</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="function" usage="rec">
              <desc versionDate="2013-04-16">définit la fonction de la marque.</desc>
              <valList type="closed">
                <valItem ident="separating">
                  <gloss>marque de séparation</gloss>
                </valItem>
                <valItem ident="emphasis">
                  <gloss>marque de mise en valeur (pour signaler un mot ou une expression
                    importants)</gloss>
                </valItem>
                <valItem ident="other"/>
              </valList>
              <!--  <datatype minOccurs="1"><dataRef key="teidata.word"/></datatype>-->
            </attDef>
            <attDef ident="rend" usage="rec">
              <desc>définit la forme de la marque</desc>
              <valList type="closed">
                <valItem ident="horizontal-line">
                  <gloss>trait horizontal</gloss>
                </valItem>
                <valItem ident="horizontal-wavy-line">
                  <gloss>trait horizontal ondulé</gloss>
                </valItem>
                <valItem ident="cross">
                  <gloss>croix</gloss>
                </valItem>
                <valItem ident="other">
                  <gloss>autre</gloss>
                </valItem>
              </valList>
            </attDef>
            <!-- <attDef ident="target" >
                                          <desc versionDate="2013-04-16" xml:lang="en">identifies one or more elements to which the metamark applies.</desc>
                                          <datatype minOccurs="1" maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
                                    </attDef>-->
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 60
              (Lucien Pierre Armand Debain, 12 août 1914) », dans <title>Testaments de guerre de
                Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École nationale
              des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-060.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-060.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="right">Nevers, le 12
                août 1914</dateline><metamark rend="horizontal-line" function="separating"/><p>Ceci
                est mon testament, écrit en<lb/> toute sérénité, la veille de mon<lb/> départ pour
                la guerre contre l’Allemagne.</p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#PH-meta"/>
          </listRef>
        </elementSpec>
        <!-- balisage "sémantique" dans la transcription -->
        <elementSpec module="core" ident="date" mode="replace">
          <gloss versionDate="2009-01-06">date</gloss>
          <desc versionDate="2009-01-06">contient une date exprimée dans n'importe quel
            format.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : peut être utilisé pour baliser une
            date importante dans le corps du testament (date de rédaction du testament le plus
            souvent). On l'utilise aussi dans les métadonnées du testament. Doit avoir un attribut
              <att>when</att> pour donner une forme normalisée, exploitable par machine, de la date.
            L'attribut <att>type</att> permettra en outre de dire de quelle date il s'agit (date de
            rédaction du testament, date de naissance du testateur, etc.). </desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.dateLike"/>
            <memberOf key="model.publicationStmtPart.detail"/>
            <!-- <memberOf key="att.datable"/>
                                    <memberOf key="att.duration"/>
                                    <memberOf key="att.editLike"/>
                                    <memberOf key="att.typed"/>-->
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
            </alternate>
          </content>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="willDate">
                  <gloss>date de rédaction du testament</gloss>
                </valItem>
                <valItem ident="codicilDate">
                  <gloss>date de rédaction du codicille</gloss>
                </valItem>
                <valItem ident="willAuthorBirthDate">
                  <gloss>date de naissance du testateur</gloss>
                </valItem>
                <valItem ident="willAuthorDeathDate">
                  <gloss>date de décès du testateur</gloss>
                </valItem>
                <valItem ident="militaryEventDate">
                  <gloss>date d'un événement militaire (bataille, offensive...)</gloss>
                </valItem>
                <valItem ident="otherDate">
                  <gloss>autre date</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="when" usage="req">
              <desc>La forme normalisée de la date au format AAA-MM-JJ</desc>
              <datatype>
                <dataRef key="teidata.temporal.w3c"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><dateline rend="right">Pourville, <date
                  when="1914-07-31" type="willDate">31 juillet 1914</date>.</dateline></egXML>
          </exemplum>
          <exemplum>
            <p>Un exemple d'utilisation de <gi>date</gi> dans les métadonnées du testament</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><msContents><summary><p><date
                      when="1914-07-31" type="willDate">1914, 31 juillet</date>. <placeName
                      type="willPlace">Paris</placeName>.</p><p><index indexName="willTypes"
                        ><term>testament olographe</term></index> de <persName ref="#FLChatin"
                        ><forename>Fernand</forename><forename>Lucien</forename><forename>Jules</forename><forename>Melchior</forename><surname>Chatin</surname></persName>,
                    mort pour la France à <placeName ref="#pl-056" type="willAuthorDeathPlace"
                      >Maroeuil (Pas-de-Calais)</placeName>, le <date when="1915-01-10"
                      type="willAuthorDeathDate">10 janvier
              1915</date>.</p></summary></msContents></egXML>
          </exemplum>
          <!-- attribute "calendar" moved to att.datable -->
          <!--<exemplum versionDate="2008-04-06" xml:lang="fr">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                          <date when="1980-02">au début de février 1980</date>
                                    </egXML>
                              </exemplum>-->
          <!--<exemplum versionDate="2008-04-06" xml:lang="fr">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples" source="#fr-ex-Pascal_Pensees">
                                          <date when="1654-11-23">L'an de grâce 1654,<lb/> Lundi, 23 novembre, jour de saint Clément,
                                                pape et martyr et autres au martyrologe, <lb/>Veille de saint Chrysogone, martyr, et
                                                autres, <lb/> Depuis environ dix heures et demie du soir jusques environ minuit et
                                                demi.</date>
                                    </egXML>
                              </exemplum>-->
          <!--<exemplum versionDate="2008-04-06" xml:lang="fr">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                          <date when="1990-09">septembre
                                                mcmxc</date>
                                          <date when="-\-09">septembre</date>
                                          <date when="2001-09-11T12:48:00">11
                                                septembre, neuf heures moins douze GMT</date>
                                    </egXML>
                              </exemplum>-->
          <listRef>
            <ptr target="#CONADA" type="div3"/>
            <ptr target="#HD24" type="div3"/>
            <ptr target="#HD6" type="div3"/>
            <ptr target="#COBICOI" type="div3"/>
            <ptr target="#CCAHSE" type="div3"/>
            <ptr target="#NDDATE"/>
          </listRef>
        </elementSpec>
        <elementSpec module="namesdates" ident="persName" mode="replace">
          <gloss versionDate="2008-12-09">nom de personne</gloss>
          <!-- <gloss versionDate="2005-01-14" xml:lang="en">personal name</gloss>-->
          <!-- <desc versionDate="2012-03-13" xml:lang="en">contains a proper noun or proper-noun phrase referring to a
                                    person, possibly including one or more of
                                    the person's forenames, surnames, honorifics, added names, etc.</desc>-->
          <desc versionDate="2008-12-09">contient un nom propre ou une expression nominale se
            référant à une personne, pouvant inclure tout ou partie de ses prénoms, noms de famille,
            titres honorifiques, noms ajoutés, etc.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : peut être utilisé dans le corps de la
            transcriptin pour baliser un nom de personne lorsque la personne fait l'objet d'une
            notice<!-- FC TO CHECK : ou dans n'importe quel cas ??-->. On l'utilise notamment dans
            la ou les mentions de signature du testament. Dans ce cas, il est recommandé de
            distinguer, dans la chaîne de caractères ainsi balisée, le nom de famille de la personne
            (afin que celui-ci, ultérieurement, puisse être mis en forme de manière spécifique dans
            l'édition de restitution). L'élément <gi>persName</gi> sert aussi pour baliser les
            métadonnées du testament et dans les notices sur les testateurs ; dans ce dernier cas,
            on pourra trouver dans cet élément les sous-éléments distinguant nom de famille,
            prénoms, particules, surnoms.</desc>
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <memberOf key="model.persStateLike"/>
            <memberOf key="model.nameLike.agent"/>
            <!--  <memberOf key="att.datable"/>
                                    <memberOf key="att.editLike"/>-->
            <!-- <memberOf key="att.personal"/>-->
            <!--  <memberOf key="att.typed"/>-->
          </classes>
          <!--<content>
                                  <!-\-  <macroRef key="macro.phraseSeq"/>-\->
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <elementRef key="surname"/>
              <elementRef key="forename"/>
              <elementRef key="nameLink"/>
              <elementRef key="addName"/>
              <elementRef key="ref"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
            </alternate>
          </content>
          <constraintSpec ident="contentIfPersNameInSigned" scheme="schematron">
            <constraint><sch:rule context="tei:persName[ancestor::tei:signed]"><sch:assert
                  test="tei:surname">Penser à baliser le nom de famille de la
                personne</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="contentIfPersNameInAuthorityRecord" scheme="schematron">
            <constraint><sch:rule context="tei:persName[parent::tei:person]"><sch:assert
                  test="tei:surname and tei:forename">L'élément persName devrait contenir au moins
                  un élément surname et un élément forename</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="contentIfPersNameInRespStmt" scheme="schematron">
            <constraint><sch:rule context="tei:persName[ancestor::tei:respStmt]"><sch:assert
                  test="@xml:id or @corresp">Dans une mention de responsabilité, l'élément persName
                  devrait avoir un identifiant (attribut xml:id) ou pointer vers un autre élément
                  persName via l'attribut @corresp</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="ref" usage="opt">
              <desc>L'attribut <att>ref</att> contient, le cas échéant, un renvoi vers la notice
                décrivant, au sein de la plate-forme de transcription, la personne dont le nom a été
                balisé.</desc>
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="full" usage="opt">
              <valList>
                <valItem ident="yes">
                  <desc>à choisir si le nom de la personne est saisi en entier, sous une forme
                    développée.</desc>
                </valItem>
                <valItem ident="abb">
                  <desc>à choisir si on saisit une forme abrégée du nom de la personne.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="xml:id" usage="opt">
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
            <attDef ident="corresp" usage="opt">
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 2
              (Émile Alexandre Gorand, 31 juillet 1914) », dans <title>Testaments de guerre de
                Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École nationale
              des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-002.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-002.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Je soussigné <persName
                  ref="#EAGorand">Émile Gorand</persName><choice><orig/><reg>,</reg></choice><lb/>
                né le 4 <choice><orig>Août</orig><reg>août</reg></choice> 1883 à Paris 10<hi
                  rend="superscript-underlined">e</hi>, lègue à ma femme<lb/> chérie Émilie Gorand
                (née Bastien) tout ce que je possède<choice><orig/><reg>,</reg></choice><lb/>
                titres, bijoux, argent, meubles et immeubles, en cas<lb/> de décès dans cette
                guerre.</p></egXML>
          </exemplum>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 2
              (Émile Alexandre Gorand, 31 juillet 1914) », dans <title>Testaments de guerre de
                Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École nationale
              des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-002.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-002.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><signed rend="right"><seg
                  type="signature"><persName ref="#EAGorand"
                      ><forename>E.</forename> <surname>Gorand</surname></persName></seg></signed></egXML>
          </exemplum>
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Index des
              testateurs : lettre G », dans <title>Testaments de guerre de Poilus parisiens
                (1914-1918) : une édition critique</title>. Paris : École nationale des chartes,
              2017-.... En ligne : <ref
                target="http://elec.enc.sorbonne.fr/testaments-de-poilus/index-testateurs/lettre-G.html#EAGorand"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/index-testateurs/lettre-G.html#EAGorand</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><person xml:id="EAGorand"
                    ><persName><surname>Gorand</surname>,
                    <forename>Emile</forename><forename>Alexandre</forename></persName><!-- etc. --></person></egXML>
          </exemplum>
          <listRef>
            <ptr target="#NDPER"/>
          </listRef>
        </elementSpec>
        <elementSpec module="namesdates" ident="orgName" mode="replace">
          <gloss versionDate="2008-12-09">nom d'organisation</gloss>
          <!-- <gloss versionDate="2005-01-14" xml:lang="en">organization name</gloss>-->
          <!-- <desc versionDate="2005-01-14" xml:lang="en">contains an organizational name.</desc>-->
          <desc versionDate="2009-03-19">contient le nom d'une organisation.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : peut être utilisé dans le corps de la
            transcription pour baliser un nom de régiment lorsque celui-ci fait l'objet d'une
            notice<!-- FC TO CHECK : ou dans n'importe quel cas ??-->. L'élément <gi>orgName</gi>
            sert aussi dans les notices descriptives des régiments ; dans ce cas il aura un attribut
              <att>full</att>. L'élément <gi>orgName</gi> a obligatoirement un attribut
              <att>type</att>.</desc>
          <!--<classes>
                                    <memberOf key="att.global"/>
                                    <memberOf key="model.nameLike.agent"/>
                                    <memberOf key="att.datable"/>
                                    <memberOf key="att.editLike"/>
                                    <memberOf key="att.personal"/>
                                    <memberOf key="att.typed"/>
                              </classes>
                              <content>
                                    <macroRef key="macro.phraseSeq"/>
                              </content>-->
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <!-- <memberOf key="model.persStateLike"/>-->
            <memberOf key="model.nameLike.agent"/>
            <!--  <memberOf key="att.datable"/>
                                    <memberOf key="att.editLike"/>-->
            <!-- <memberOf key="att.personal"/>-->
            <!--  <memberOf key="att.typed"/>-->
          </classes>
          <!--<content>
                                  <!-\-  <macroRef key="macro.phraseSeq"/>-\->
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <elementRef key="placeName"/>
              <elementRef key="ref"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
            </alternate>
          </content>
          <constraintSpec ident="attrIfOrgNameInAuthorityRecord" scheme="schematron">
            <constraint><sch:rule context="tei:orgName[parent::tei:org]"><sch:assert test="@full"
                  >Indiquer si le nom est donné sous sa forme développée ou
                abrégée</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="regiment">
                  <gloss>nom de régiment</gloss>
                </valItem>
                <!-- FC TO CHECK : autres cas ?? -->
              </valList>
            </attDef>
            <attDef ident="ref" usage="opt">
              <desc>L'attribut <att>ref</att> contient, le cas échéant, un renvoi vers la notice
                décrivant, au sein de la plate-forme de transcription, le régiment dont le nom a été
                balisé.</desc>
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="full" usage="opt">
              <valList>
                <valItem ident="yes">
                  <desc>à choisir si le nom du régiment est saisi développé.</desc>
                </valItem>
                <valItem ident="abb">
                  <desc>à choisir si on saisit une forme abrégée du nom du régiment.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <!--   <exemplum xml:lang="en">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples">About a year back, a question of considerable interest was agitated in the <orgName key="PAS1" type="voluntary"><placeName key="PEN">Pennsyla.</placeName> Abolition Society</orgName> [...]</egXML>
                              </exemplum>-->
          <!-- <exemplum versionDate="2008-04-06" xml:lang="fr">
                                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                          <orgName key="ssav" type="regional">Société savoisienne de <placeName key="GRE">Grenoble</placeName>
                                          </orgName>
                                    </egXML>
                              </exemplum>-->
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>Je soussigné <persName
                  ref="#PFeugere">Paul Louis
                    <surname>Feugère</surname></persName><choice><orig/><reg>,</reg></choice><lb/>
                soldat au <orgName type="regiment">150<hi rend="sup">e</hi> régiment
                      <choice><orig>d’Infanterie</orig><reg>d’infanterie</reg></choice></orgName><lb/>
                en garnison à <choice><orig>Saint Mihiel</orig><reg>Saint-Mihiel</reg></choice>
                (Meuse)<!-- [...]--></p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#NDORG"/>
          </listRef>
        </elementSpec>
        <elementSpec module="namesdates" ident="placeName" mode="replace">
          <gloss versionDate="2008-12-09">nom de lieu</gloss>
          <!--gloss>place name</gloss-->
          <!-- <desc versionDate="2005-01-14" xml:lang="en">contains an absolute or relative place name.</desc>-->
          <desc versionDate="2009-03-19">contient un nom de lieu absolu ou relatif.</desc>
          <desc type="wills-ui"> Peut être utilisé dans le corps de la transcription pour baliser un
            nom de lieu lorsque le lieu fait l'objet d'une
            notice<!-- FC TO CHECK : ou dans n'importe quel cas ??-->. L'élément <gi>placeName</gi>
            sert aussi pour baliser les métadonnées du testament. Dans ces deux cas, l'attribut
              <att>type</att> permettra de dire de quel type de lieu il s'agit (lieu de rédaction du
            testament, lieu de naissance ou de décès du testateur, etc.). Enfin, cet élément est
            aussi utilisé dans les notices sur les lieux ; dans ce dernier cas, on trouvera dans cet
            élément les sous-éléments distinguant les composants du nom de lieu : nom de lieu
            habité, nom de lieu géographique, type générique de lieu (forêt, montagne...). Toujours
            dans le cas de la notice sur un lieu, le nom de lieu pourra le cas échéant avoir un
            attribut <att>when-iso</att> pour spécifier les dates d'utilisation de ce nom de
            lieu.</desc>
          <classes>
            <!-- <memberOf key="att.datable"/>
                                    <memberOf key="att.editLike"/>
                                    <memberOf key="att.global"/>
                                    <memberOf key="att.personal"/>
                                    <memberOf key="att.typed"/>-->
            <memberOf key="model.placeNamePart"/>
          </classes>
          <!-- <content>
                                    <macroRef key="macro.phraseSeq"/>
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <elementRef key="geogName"/>
              <elementRef key="geogFeat"/>
              <elementRef key="settlement"/>
              <elementRef key="ref"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
            </alternate>
          </content>
          <constraintSpec ident="contentIfPlaceNameInAuthorityRecord" scheme="schematron">
            <constraint><sch:rule context="tei:placeName[ancestor::tei:place]"><sch:assert
                  test="tei:settlement or tei:geogName or tei:geogFeat">Dans une notice sur un lieu,
                  l'élément placeName devrait contenir au moins un
                sous-élément</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="attrTypeIfPlaceNameInTranscriptionOrWillMetadata"
            scheme="schematron">
            <constraint><sch:rule
                context="tei:placeName[ancestor::tei:summary or ancestor::tei:div[@type='will'] or ancestor::tei:div[@type='envelope']]"
                  ><sch:assert test="@type">Dans les métadonnées sur le testament ou dans le corps
                  de la transcription, l'élément placeName devrait avoir un attribut
                  type</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="ref" usage="opt">
              <desc>L'attribut <att>ref</att> contient, le cas échéant, un renvoi vers la notice
                décrivant, au sein de la plate-forme de transcription, le lieu dont le nom a été
                balisé.</desc>
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="type" usage="opt">
              <valList type="closed">
                <valItem ident="willPlace">
                  <gloss>lieu de rédaction du testament</gloss>
                </valItem>
                <valItem ident="codicilPlace">
                  <gloss>lieu de rédaction du codicille</gloss>
                </valItem>
                <valItem ident="willAuthorBirthPlace">
                  <gloss>lieu de naissance du testateur</gloss>
                </valItem>
                <valItem ident="willAuthorDeathPlace">
                  <gloss>lieu de décès du testateur</gloss>
                </valItem>
                <valItem ident="willAuthorResidence">
                  <gloss>domicile du testateur</gloss>
                </valItem>
                <valItem ident="militaryEventPlace">
                  <gloss>lieu d'un événement militaire (bataille, offensive...)</gloss>
                </valItem>
                <valItem ident="otherPlace">
                  <gloss>autre date</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="when-iso" usage="opt">
              <desc>la forme normalisée de la période pendant laquelle le nom de lieu a été utilisé
                (dans une notice sur un nom de lieu)</desc>
              <datatype>
                <dataRef key="teidata.temporal.iso"/>
              </datatype>
            </attDef>
            <!-- <attDef ident="full" usage="opt">
                                          <valList>
                                                <valItem ident="yes"><desc>à choisir si le nom de la personne est saisi en entier, sous une forme développée.</desc></valItem>
                                                <valItem ident="abb"><desc>à choisir si on saisit une forme abrégée du nom de la personne.</desc></valItem>
                                          </valList>
                                    </attDef>-->
          </attList>
          <exemplum>
            <p>Un exemple d'utilisation de <gi>placeName</gi> dans les métadonnées du testament</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><msContents><summary><p><date
                      when="1914-07-31" type="willDate">1914, 31 juillet</date>. <placeName
                      type="willPlace">Paris</placeName>.</p><p><index indexName="willTypes"
                        ><term>testament olographe</term></index> de <persName ref="#FLChatin"
                        ><forename>Fernand</forename><forename>Lucien</forename><forename>Jules</forename><forename>Melchior</forename><surname>Chatin</surname></persName>,
                    mort pour la France à <placeName ref="#pl-056" type="willAuthorDeathPlace"
                      >Maroeuil (Pas-de-Calais)</placeName>, le <date when="1915-01-10"
                      type="willAuthorDeathDate">10 janvier
              1915</date>.</p></summary></msContents></egXML>
          </exemplum>
          <exemplum>
            <p>Un exemple d'utilisation de <gi>placeName</gi> dans une notice descriptive de
              lieu</p>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Index des lieux
              de décès : lettre M », dans <title>Testaments de guerre de Poilus parisiens
                (1914-1918) : une édition critique</title>. Paris : École nationale des chartes,
              2017-.... En ligne : <ref
                target="http://elec.enc.sorbonne.fr/testaments-de-poilus/index-lieux-deces/lettre-M.html#pl-056"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/index-lieux-deces/lettre-M.html#pl-056</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><place xml:id="pl-056"><placeName
                  when-iso="1793/"><settlement type="cantonCapital"
                  >Maroeuil</settlement></placeName><location><district type="departement"
                    >Pas-de-Calais</district><region>Nord-Pas-de-Calais-Picardie</region><country>France</country></location><location
                  type="geographicalCoordinates"><geo>50.32519 2.70504</geo></location><idno
                  type="geonamesURI">http://sws.geonames.org/2995586/</idno></place></egXML>
          </exemplum>
          <listRef>
            <ptr target="#NDPLAC"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="term" mode="replace">
          <gloss versionDate="2009-01-06">terme</gloss>
          <!-- <desc versionDate="2005-01-14" xml:lang="en">contains a single-word, multi-word, or symbolic
                                    designation which is regarded as a technical term.</desc>-->
          <desc versionDate="2009-01-06">contient un mot simple, un mot composé ou un symbole, qui
            est considéré comme un terme technique.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : peut être utilisé dans le corps de la
            transcription (?), dans les notes historiques ou d'apparat critique, et dans les
            métadonnées du testament. Devrait normalement avoir un attribut <att>type</att>.</desc>
          <classes>
            <!-- <memberOf key="att.global"/>-->
            <memberOf key="model.emphLike"/>
            <!-- <memberOf key="att.declaring"/>
                                    <memberOf key="att.pointing"/>
                                    <memberOf key="att.typed"/>
                                    <memberOf key="att.canonical"/>
                                    <memberOf key="att.sortable"/>
                                    <memberOf key="att.cReferencing"/>-->
          </classes>
          <!--<content>
                                   <!-\- <macroRef key="macro.phraseSeq"/>-\->
                              </content>-->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="app"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="ref"/>
            </alternate>
          </content>
          <constraintSpec ident="ifTermThenAttrType" scheme="schematron">
            <constraint><sch:rule context="tei:term"><sch:assert test="@type">Vous devriez
                  catégoriser le terme que vous avez balisé l'aide de l'attribut
                type</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="rec">
              <valList type="closed">
                <valItem ident="willType">
                  <gloss>type de testament (dans les métadonnées du testament)</gloss>
                </valItem>
                <valItem ident="other">
                  <gloss>autre catégorie de terme</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><msContents><summary><p><date
                      when="1914-07-31" type="willDate">1914, 31 juillet</date>. <placeName
                      type="willPlace">Paris</placeName>.</p><p><term type="willType">testament
                      olographe</term> de <persName ref="#FLChatin"
                        ><forename>Fernand</forename><forename>Lucien</forename><forename>Jules</forename><forename>Melchior</forename><surname>Chatin</surname></persName>,
                    mort pour la France à <placeName ref="#pl-056" type="willAuthorDeathPlace"
                      >Maroeuil (Pas-de-Calais)</placeName>, le <date when="1915-01-10"
                      type="willAuthorDeathDate">10 janvier
              1915</date>.</p></summary></msContents></egXML>
          </exemplum>
          <!--<remarks versionDate="2009-01-23" xml:lang="en">
                                    <p>When this element appears within an <gi>index</gi> element, it is understood to supply the
                                          form under which an index entry is to be made for that location. Elsewhere, it is understood
                                          simply to indicate that its content is to be regarded as a technical or specialised term. It
                                          may be associated with a <gi>gloss</gi> element by means of its <att>ref</att> attribute;
                                          alternatively a <gi>gloss</gi> element may point to a <gi>term</gi> element by means of its
                                          <att>target</att> attribute. </p>
                                    <p>In formal terminological work, there is frequently discussion over whether terms must be
                                          atomic or may include multi-word lexical items, symbolic designations, or phraseological
                                          units. The <gi>term</gi> element may be used to mark any of these. No position is taken on the
                                          philosophical issue of what a term can be; the looser definition simply allows the
                                          <gi>term</gi> element to be used by practitioners of any persuasion.</p>
                                    <p>As with other members of the <ident type="class">att.canonical</ident> class, instances of
                                          this element occuring in a text may be associated with a canonical definition, either by means
                                          of a URI (using the <att>ref</att> attribute), or by means of some system-specific code value
                                          (using the <att>key</att> attribute). Because the mutually exclusive <att>target</att> and
                                          <att>cRef</att> attributes overlap with the function of the <att>ref</att> attribute, they
                                          are deprecated and may be removed at a subsequent release. </p>
                              </remarks>-->
          <listRef>
            <ptr target="#COHQU"/>
          </listRef>
        </elementSpec>
        <!-- notes et apparat critique -->
        <elementSpec module="core" ident="ref" mode="replace">
          <gloss versionDate="2009-01-06">référence</gloss>
          <!--  <gloss versionDate="2007-07-04" xml:lang="en">reference</gloss>-->
          <!-- <desc versionDate="2006-01-11" xml:lang="en">defines a reference to another location, possibly modified by additional text or comment.</desc>-->
          <desc versionDate="2009-01-06">définit une référence vers un autre emplacement, la
            référence étant éventuellement modifiée ou complétée par un texte ou un
            commentaire.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : utilisé pour créer un appel de note
            dans le corps de la transcription, dans le cas des notes historiques et commentaires
            explicatifs sur le contenu du testament ; dans ce cas l'élément est vide. Egalement
            utilisé, dans les notes elles-mêmes, et dans les notices sur les personnes, les lieux et
            les régiments, pour renvoyer à des ressources bibliographiques en ligne. Cet élément
            devrait toujours avoir un attribut <att>target</att>.</desc>
          <classes>
            <!--<memberOf key="att.global"/>-->
            <memberOf key="model.ptrLike"/>
            <!--  <memberOf key="att.pointing"/>-->
            <!-- <memberOf key="att.internetMedia"/>-->
            <!--<memberOf key="att.typed"/>
                                    <memberOf key="att.declaring"/>
                                    <memberOf key="att.cReferencing"/>-->
          </classes>
          <content>
            <!--<macroRef key="macro.paraContent"/>-->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <!-- <elementRef key="persName"/>
                                                <elementRef key="placeName"/>
                                                <elementRef key="orgName"/>
                                                <elementRef key="date"/>
                                                <elementRef key="seg"/>
                                                <elementRef key="term"/>-->
            </alternate>
          </content>
          <constraintSpec ident="refEmptyIfInTranscription" scheme="schematron">
            <constraint><sch:rule
                context="tei:ref[ancestor::tei:div[@type='will' or @type='envelope']]"><sch:assert
                  test="normalize-space(.)=''">L'élément ref est vide lorsqu'il établit un renvoi
                  vers une note sur le contenu du testament
              transcrit.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="refHasContentIfInNote" scheme="schematron">
            <constraint><sch:rule
                context="tei:ref[ancestor::tei:div[@type='notes'] or ancestor::tei:person or ancestor::tei:place or ancestor::tei:org]"
                  ><sch:assert test="normalize-space(.)!=''">L'élément ref a un contenu textuel
                  lorsqu'il établit un renvoi vers une ressource en ligne depuis une note ou depuis
                  une notice descriptive.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <constraintSpec ident="attrTargetOnRef" scheme="schematron">
            <constraint><sch:rule context="tei:ref"><sch:assert test="@target">L'attribut target est
                  obligatoire pour cet élément.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="target" usage="req">
              <gloss>la cible du renvoi</gloss>
              <datatype>
                <dataRef key="teidata.pointer"/>
              </datatype>
            </attDef>
            <attDef ident="xml:id" usage="opt">
              <gloss>identifiant unique du renvoi</gloss>
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
            <attDef ident="type" usage="opt">
              <gloss>catégorie de renvoi</gloss>
              <valList type="closed">
                <valItem ident="internal">
                  <gloss>renvoi interne à l'édition du testament en cours</gloss>
                </valItem>
                <valItem ident="external">
                  <gloss>renvoi à une ressource externe</gloss>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <!--<constraintSpec scheme="schematron" ident="refAtts">
                                    <constraint>
                                          <report xmlns="http://purl.oclc.org/dsdl/schematron" test="@target and @cRef">Only one of the
                                                attributes @target' and @cRef' may be supplied on <name/>
                                          </report>
                                    </constraint>
                              </constraintSpec>-->
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><item>3°
                    <choice><orig>à</orig><reg>À</reg></choice> mon frère Paul Chatin de Chastaing
                  <ref xml:id="will-001-001" target="#will-001-footnote001" type="internal"/><lb/>
                une somme de cinq mille francs et<lb/> ma montre à
                    sonnerie<choice><orig/><reg>.</reg></choice></item></egXML>
          </exemplum>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="notes"><note
                  xml:id="will-001-footnote001" resp="#MDurand #FClavaud">Sur Paul Chatin de
                  Chastaing, voir <bibl>une référence biblio avec un <title>titre</title></bibl>, et
                  consulter <ref target="http://www.bnf.fr" type="external">une page
                  web</ref>.</note></div></egXML>
          </exemplum>
          <listRef>
            <ptr target="#COXR"/>
            <ptr target="#SAPT"/>
          </listRef>
        </elementSpec>
        <elementSpec module="core" ident="note" mode="replace">
          <gloss>note</gloss>
          <!--   <desc versionDate="2005-01-14" xml:lang="en">contains a note or annotation.</desc>-->
          <desc versionDate="2009-01-06">contient une note ou une annotation</desc>
          <desc type="wills-ui"> Projet Testaments de Poilus : utilisé par les éditeurs pour saisir
            les notes sur le contenu des testaments (dans ce cas, l'élément <gi>note</gi> est
            enregistré dans l'élément <gi>back</gi>) ou les notes d'apparat critique relatives à la
            forme de la transcription (dans ce cas l'élément <gi>note</gi> est enregistré dans
            l'élément <gi>app</gi> dans le corps de la transcription). Dans ces deux cas cet élément
            a obligatoirement un attribut <att>resp</att> qui désigne le ou les auteurs de la note.
            Dans de rares cas, l'élément <gi>note</gi> sert à encoder une note du testateur
            lui-même, ajoutée en marge, relative le plus souvent à un ou des mots qu'il a rayés dans
            le testament. </desc>
          <classes>
            <!--  <memberOf key="att.global"/>-->
            <memberOf key="model.noteLike"/>
            <!-- <memberOf key="att.placement"/>
                                    <memberOf key="att.pointing"/>
                                    <memberOf key="att.typed"/>
                                    <memberOf key="att.written"/-->
            <memberOf key="model.correspDescPart"/>
            <memberOf key="model.correspActionPart"/>
            <memberOf key="model.correspContextPart"/>
          </classes>
          <content>
            <!-- <macroRef key="macro.specialPara"/>-->
            <alternate>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <textNode/>
                <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
                <elementRef key="lb"/>
                <elementRef key="choice"/>
                <elementRef key="gap"/>
                <elementRef key="unclear"/>
                <elementRef key="supplied"/>
                <elementRef key="damage"/>
                <elementRef key="add"/>
                <elementRef key="del"/>
                <elementRef key="subst"/>
                <elementRef key="app"/>
                <elementRef key="hi"/>
                <!--<classRef key="model.pPart.transcriptional"/>-->
                <elementRef key="placeName"/>
                <elementRef key="date"/>
                <elementRef key="persName"/>
                <elementRef key="orgName"/>
                <elementRef key="seg"/>
                <elementRef key="term"/>
                <elementRef key="ref"/>
              </alternate>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <textNode/>
                <!--<classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.global"/>
                                          <elementRef key="docDate"/>-->
                <elementRef key="hi"/>
                <elementRef key="ref"/>
                <elementRef key="bibl"/>
                <elementRef key="term"/>
                <!--<classRef key="model.pPart.transcriptional"/>-->
                <!-- <elementRef key="persName"/>
                                                <elementRef key="placeName"/>
                                                <elementRef key="orgName"/>
                                                <elementRef key="date"/>
                                                <elementRef key="seg"/>
                                                <elementRef key="term"/>-->
              </alternate>
            </alternate>
          </content>
          <!--<constraintSpec ident="noteContentInTranscription"
                                    scheme="schematron">
                                    <constraint><sch:rule context="tei:note[not(ancestor::tei:div[@type='notes']) and not(parent::tei:app)]"><sch:assert
                                                  test="not(tei:bibl)">Taper
                                                  ici, en le faisant précéder d'un caractère dièse
                                                  (#), l'identifiant du contributeur qui a créé la
                                                  note. S'il y a plusieurs contributeurs, taper une
                                                  espace entre chaque
                                                référence.</sch:assert></sch:rule></constraint>
                              </constraintSpec>-->
          <constraintSpec ident="attrIdOnHistoricalNote" scheme="schematron">
            <constraint><sch:rule context="tei:note[ancestor::tei:div[@type='notes']]"><sch:assert
                  test="@xml:id">L'attribut xml:id est obligatoire pour cet
                élément.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="resp" usage="rec">
              <datatype maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valDesc>contient, séparés par des espaces, des pointeurs vers les identités des
                personnes qui ont contribué à l'édition du testament et en particulier, en
                l'occurrence, à la saisie de la forme corrigée, telles que déclarées dans un des
                éléments <gi>respStmt</gi> de <gi>teiHeader</gi>.</valDesc>
            </attDef>
            <attDef ident="xml:id" usage="opt">
              <gloss>identifiant unique de la note</gloss>
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
          </attList>
          <exemplum>
            <p>Une note d'apparat critique</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><item>5°
                    <choice><orig>à</orig><reg>À</reg></choice> mon vieil ami Morel mon fusil<lb/>
                calibre 12 percussion centrale <app><lem> (de Warn<supplied reason="hidden"
                      resp="#MDurand">er</supplied>)</lem><note resp="#MDurand">Tache d’encre à la
                    fin du mot.</note></app>
                <choice><orig/><reg>.</reg></choice><lb/> Mon ami Morel habite 2
                    <choice><orig>Rue</orig><reg>rue</reg></choice> Lénac<lb/> à
              Marseille.</item></egXML>
          </exemplum>
          <exemplum>
            <p>Une note éditoriale sur le contenu du testament</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><div type="notes"><note
                  xml:id="will-001-footnote001" resp="#MDurand #FClavaud">Sur Paul Chatin de
                  Chastaing, voir <bibl>une référence biblio avec un <title>titre</title></bibl>, et
                  consulter <ref target="http://www.bnf.fr">une page web</ref>.</note></div></egXML>
          </exemplum>
          <exemplum>
            <p>Une note d'un testateur dans une addition marginale au testament, faisant suite à la
              suppression de deux mots. Cette note est accompagnée d'une note d'apparat critique de
              l'éditeur.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p>En cas d’existence<lb/> d’enfants,
                          <app><lem><choice><orig><del>je le</del><add place="marginLeft"><note>rayé
                            deux mots nuls J. V.</note></add></orig><reg/></choice></lem><note
                    resp="#FClavaud">"rayé deux mots nuls J.V." inscrit dans la marge.</note></app>
                ce<lb/> legs sera réduit à la<lb/> plus forte quotité<lb/> disponible permise
                entre<lb/> époux tant en toute<lb/> propriété qu’en usufruit<lb/> et cette quotité
                disponible<lb/> sera calculée sur l’ensemble<lb/> de ma succession, y<lb/> compris
                les rapports. </p></egXML>
          </exemplum>
          <listRef>
            <ptr target="#CONONO" type="div2"/>
            <ptr target="#HD27"/>
            <ptr target="#COBICON"/>
            <ptr target="#DITPNO"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textcrit" ident="app" mode="replace">
          <gloss versionDate="2007-06-12">entrée d'apparat critique</gloss>
          <!--<gloss versionDate="2005-01-14" xml:lang="en">apparatus entry</gloss>-->
          <!--<desc versionDate="2013-10-17" xml:lang="en">contains one entry in a critical apparatus, with an optional
lemma and usually one or more readings or notes on the relevant passage.</desc>-->
          <desc versionDate="2007-06-12">contient une entrée dans un apparat critique, constituée
            d'un lemme facultatif et d'au moins une leçon.</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : cet élément est utilisé dans le corps
            de la transcription lorsqu'on observe un micro-phénomène textuel (addition, suppression,
            abréviation, erreur de syntaxe, dommage matériel, texte superflu, etc.) que l'on
            souhaite commenter par une note d'apparat critique. Il contient obligatoirement un
            élément <gi>lem</gi> (englobant le texte transcrit) suivi d'un élément
            <gi>note</gi>.</desc>
          <classes>
            <!--<memberOf key="att.global"/>-->
            <memberOf key="model.global.edit"/>
          </classes>
          <content>
            <!--<sequence>
      <elementRef key="lem" minOccurs="0"/>
    <alternate maxOccurs="unbounded" minOccurs="0">
      <classRef key="model.rdgLike"/>
      <classRef key="model.noteLike"/>
      <elementRef key="wit"/>      
      <elementRef key="rdgGrp"/>      
    </alternate>
   </sequence>-->
            <sequence>
              <elementRef key="lem"/>
              <elementRef key="note"/>
            </sequence>
          </content>
          <constraintSpec ident="appContent" scheme="schematron">
            <constraint><sch:rule context="tei:app"><sch:assert test="tei:lem and tei:note">Si vous
                  utilisez une entrée d'apparat critique, elle doit obligatoirement comporter à la
                  fois le balisage de la partie de texte transcrite objet de la note d'apparat
                  critique, et la note d'apparat critique.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" usage="opt">
              <gloss>identifiant unique de l'entrée d'apparat critique</gloss>
              <datatype>
                <dataRef name="ID"/>
              </datatype>
            </attDef>
            <!--<attDef ident="type" usage="opt">
      <desc versionDate="2005-01-14" xml:lang="en">classifies the variation contained in this element according to
some convenient typology.</desc>
      <desc versionDate="2007-12-20" xml:lang="ko">다양한 유형에 따라 이 요소에 포함된 변이형을 분류한다.</desc>
      <desc versionDate="2007-05-02" xml:lang="zh-TW">利用合適的分類法將此元素所標記的變異分類。</desc>
      <desc versionDate="2008-04-05" xml:lang="ja">当該要素で示される対象を分類する．</desc>
      <desc versionDate="2007-06-12" xml:lang="fr">classifie la variation contenue dans cet
					élément selon toute typologie adéquate.</desc>
      <desc versionDate="2007-05-04" xml:lang="es">clasifica la variación contenida en tal elemento según una tipología funcional</desc>
      <desc versionDate="2007-01-21" xml:lang="it">classifica la variazione contenuta in tale elemento secondo una tipologia funzionale</desc>
      <datatype><dataRef key="teidata.enumerated"/></datatype>
    </attDef>-->
            <!--<attDef ident="from" usage="opt">
      <desc versionDate="2013-04-11" xml:lang="en">identifies the beginning of the lemma in the base text.</desc>
      <desc versionDate="2007-12-20" xml:lang="ko">필요하다면 기본 텍스트에서 레마의 시작을 식별한다.</desc>
      <desc versionDate="2007-05-02" xml:lang="zh-TW">必要情況下，指出基礎文件中該主題的開端。</desc>
      <desc versionDate="2008-04-05" xml:lang="ja">必要であれば，元テキストにおける対象語(lemma)の開始点を示す．</desc>
      <desc versionDate="2007-06-12" xml:lang="fr">identifie, si nécessaire, le début du
					lemme dans le texte de base.</desc>
      <desc versionDate="2007-05-04" xml:lang="es">identifica, si es necesario, el inicio del lema en el texto base</desc>
      <desc versionDate="2007-01-21" xml:lang="it">identifica, se necessario, l'inizio del lemma nel testo base</desc>
      <datatype><dataRef key="teidata.pointer"/></datatype>
      <remarks versionDate="2013-06-18" xml:lang="en">
        <p>This attribute should be used when either the 
          double-end point method of apparatus markup, or the location-referenced 
          method with a URL rather than canonical reference, are used.</p>
      </remarks>
      <remarks xml:lang="fr" versionDate="2007-06-12">
        <p>Cet attribut n'est utilisé que si l'on emploie la méthode de balisage de
                        l'apparat critique dite "double-end point", c'est-à-dire que l'on indique le
                        début et la fin du bloc de texte balisé. </p>
      </remarks>
      <remarks xml:lang="ja" versionDate="2008-04-05">
        <p>
	当該属性は，校勘資料中で，両端ポイントの手法が使用されてい
      る場合に使われる．
       </p>
      </remarks>
    </attDef>-->
            <!--<attDef ident="to" usage="opt">
      <desc versionDate="2013-04-11" xml:lang="en">identifies the endpoint of the lemma in the base text.</desc>
      <desc versionDate="2007-12-20" xml:lang="ko">필요하다면 기본 텍스트에서 레마의 종료지점을 식별한다.</desc>
      <desc versionDate="2007-05-02" xml:lang="zh-TW">必要情況下，指出基礎文件中該主題的結尾。</desc>
      <desc versionDate="2008-04-05" xml:lang="ja">必要であれば，元テキストにおける対象語(lemma)語の終点を示す．</desc>
      <desc versionDate="2007-06-12" xml:lang="fr">identifie, si nécessaire, la fin du lemme
					dans le texte de base.</desc>
      <desc versionDate="2007-05-04" xml:lang="es">identifica, si es necesario, el final del lema en el texto base</desc>
      <desc versionDate="2007-01-21" xml:lang="it">identifica, se necessario, la fine del lemma nel testo base</desc>
      <datatype><dataRef key="teidata.pointer"/></datatype>
      <remarks versionDate="2013-06-18" xml:lang="en">
        <p>This attribute is only used when the double-end point
                method of apparatus markup is used, when the encoded apparatus is not
                embedded <term>in-line</term> in the base-text.</p>
      </remarks>
      <remarks xml:lang="fr" versionDate="2007-06-12">
        <p>Cet attribut n'est utilisé que si l'on emploie la méthode de balisage de
                        l'apparat critique dite "double-end point", avec l'apparat encodé enregistré
                        dans un fichier séparé plutôt qu'incorporé au fil du texte
                        (<term>in-line</term>) dans le fichier du texte de base.</p>
      </remarks>
      <remarks xml:lang="ja" versionDate="2008-04-05">
        <p>
	当該属性は，校勘資料中で，両端ポイントの手法が使用されている場
    合に使われる．これは，元テキストファイルの<term>テキスト列中
    </term>に埋め込まれているのではなく，別のファイル中にある校勘
    資料中のものである．
    </p>
      </remarks>
    </attDef>-->
            <!--<attDef ident="loc" usage="opt">
      <gloss versionDate="2007-07-04" xml:lang="en">location</gloss>
      <gloss versionDate="2007-12-20" xml:lang="ko">위치</gloss>
      <gloss versionDate="2008-04-06" xml:lang="es">localización</gloss>
      <gloss versionDate="2008-03-30" xml:lang="fr">emplacement</gloss>
      <gloss versionDate="2007-11-06" xml:lang="it">posizione</gloss>
      <desc versionDate="2005-01-14" xml:lang="en">indicates the location of the variation, when the
location-referenced method of apparatus markup is used.</desc>
      <desc versionDate="2007-12-20" xml:lang="ko">참조 도구 마크업의 위치 참조 방법이 사용될 때 변이형 위치를 나타낸다.</desc>
      <desc versionDate="2007-05-02" xml:lang="zh-TW">使用學術編輯註解標記的位置參照辦法時，指出變異的位置。</desc>
      <desc versionDate="2008-04-05" xml:lang="ja">校勘資料で場所参照の手法が採られている場合，該当する異なりの場所
    を示す．</desc>
      <desc versionDate="2007-06-12" xml:lang="fr">indique la localisation de la variante
					lorsqu'on utilise dans l'encodage de l'apparat critique une méthode de
					référencement des localisations.</desc>
      <desc versionDate="2007-05-04" xml:lang="es">indica la posición de la variante en caso de usar el método de señalización de la posición de la variante en la codificación del aparato.</desc>
      <desc versionDate="2007-01-21" xml:lang="it">indica la posizione della variante in caso di utilizzo del metodo di indicazione della posizione della variante nella codifica dell'apparato</desc>
      <datatype maxOccurs="unbounded"><dataRef key="teidata.word"/></datatype>
      <remarks versionDate="2013-11-22" xml:lang="en">
        <p>This attribute is used only when the location-referenced
encoding method is used.  It supplies a  string containing a canonical reference for the passage
      to which the variation applies.</p>
      </remarks>
      <remarks xml:lang="fr" versionDate="2007-06-12">
        <p>Cet attribut n'est utilisé que si l'on emploie la méthode de codage par
                        référence à un emplacement ("location-referenced").</p>
      </remarks>
      <remarks xml:lang="ja" versionDate="2008-04-05">
        <p>
	当該属性は，場所参照手法が採られている場合にのみ使用される．
	 <!-\- [Suppress it and use <att>from</att> instead?  -MSM]
    -\->
    </p>
      </remarks>
    </attDef>-->
          </attList>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><item>5°
                    <choice><orig>à</orig><reg>À</reg></choice> mon vieil ami Morel mon fusil<lb/>
                calibre 12 percussion centrale <app><lem> (de Warn<supplied reason="hidden"
                      resp="#MDurand">er</supplied>)</lem><note resp="#MDurand">Tache d’encre à la
                    fin du mot.</note></app>
                <!-- [...] --></item></egXML>
          </exemplum>
          <!--  <remarks>
    <p rend="dataDesc">May contain an optional lemma and one or more readings or
reading groups, each associated with witness specifications.</p>
  </remarks>
  <remarks xml:lang="fr" versionDate="2007-06-12">
    <p rend="dataDesc">Peut contenir un lemme facultatif et une ou plusieurs leçons ou
                groupe de leçons, chacune associée à des spécifications de témoin.</p>
  </remarks>
  <remarks xml:lang="ja" versionDate="2008-04-05"><p rend="dataDesc">
    複数の読み，読みのまとまり，ひとつの選択的な対象語(lemma)をとる．
    </p>
  </remarks>-->
          <listRef>
            <ptr target="#TCAPEN"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textcrit" ident="lem" mode="replace">
          <gloss versionDate="2007-06-12">lemme (texte de base)</gloss>
          <!--<gloss versionDate="2005-01-14" xml:lang="en">lemma</gloss>
                             -->
          <!-- <desc versionDate="2005-01-14" xml:lang="en">contains the lemma, or base text, of a textual variation.</desc>-->
          <desc versionDate="2007-06-12">contient le lemme ou le texte de base d'une variante
            textuelle</desc>
          <desc type="wills-ui">Projet Testaments de Poilus : dans le cadre de ce projet o il
            n'existe qu'un seul témoin textuel pour un testament donné, l'élément <gi>lem</gi> est
            utilisé, au sein de l'entrée d'apparat critique <gi>app</gi>, pour saisir la
            transcription d'une partie du texte que l'on souhaite commenter par une note d'apparat
            critique.</desc>
          <classes><!-- <memberOf key="att.global"/>
                                    <memberOf key="att.textCritical"/>
                                    <memberOf key="att.witnessed"/>--></classes>
          <content>
            <!-- <alternate minOccurs="0" maxOccurs="unbounded">
                                          <textNode/>
                                         <!-\- <classRef key="model.divLike"/>
                                          <classRef key="model.divPart"/>
                                          <classRef key="model.gLike"/>
                                          <classRef key="model.phrase"/>
                                          <classRef key="model.inter"/>
                                          <classRef key="model.global"/>
                                          <classRef key="model.rdgPart"/>-\->
                                    </alternate>
                                    -->
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <elementRef key="lb"/>
              <elementRef key="pb"/>
              <elementRef key="choice"/>
              <elementRef key="gap"/>
              <elementRef key="unclear"/>
              <elementRef key="supplied"/>
              <elementRef key="damage"/>
              <elementRef key="add"/>
              <elementRef key="del"/>
              <elementRef key="subst"/>
              <elementRef key="hi"/>
              <!--<classRef key="model.pPart.transcriptional"/>-->
              <elementRef key="placeName"/>
              <elementRef key="date"/>
              <elementRef key="persName"/>
              <elementRef key="orgName"/>
              <elementRef key="seg"/>
              <elementRef key="term"/>
            </alternate>
          </content>
          <constraintSpec ident="lemSibling" scheme="schematron">
            <constraint><sch:rule context="tei:lem"><sch:assert
                  test="following-sibling::*[1][self::tei:note]">Si vous utilisez l'élément lem, il
                  doit être suivi, dans l'élément note, de la note d'apparat critique roprement
                  dite.</sch:assert></sch:rule></constraint>
          </constraintSpec>
          <!-- <remarks versionDate="2005-01-14" xml:lang="en">
                                    <p>The term <term>lemma</term> is used in text criticism to
                                          describe the reading in the text itself (as opposed to those in the
                                          apparatus); this usage is distinct from that of mathematics (where a
                                          lemma is a major step in a proof) and natural-language processing
                                          (where a lemma is the dictionary form associated with an inflected
                                          form in the running text).</p>
                              </remarks>-->
          <!--<remarks xml:lang="fr" versionDate="2007-06-12">
                                    <p>Le terme <term>lemma</term> est utilisé dans la critique textuelle pour décrire la
                                          leçon dans le texte lui-même (par opposition à l'apparat) ; cette acception est
                                          différente du sens en mathématiques (où un lemme est une étape majeure dans une
                                          démonstration) et du sens dans le domaine du traitement du langage naturel (où un
                                          lemme est la forme du dictionnaire associée à une forme fléchie dans le texte
                                          courant).</p>
                              </remarks>-->
          <exemplum>
            <p>Extrait tiré de Nougaret (Christine), Clavaud (Florence) (dirs.), « Testament n° 56
              (Lucien Jean Baptiste Brivois, 7 août 1914) », dans <title>Testaments de guerre de
                Poilus parisiens (1914-1918) : une édition critique</title>. Paris : École nationale
              des chartes, 2017-.... En ligne : <ref
                target=" http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-056.html#transcription"
                >
                http://elec.enc.sorbonne.fr/testaments-de-poilus/testaments/testament-056.html</ref>.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><postscript><p><app><lem>Ayant fait de
                      mauvaises affaires<choice><orig/><reg>,</reg></choice> ma fortune en<lb/>
                      valeurs est presque disparue<choice><orig> - ma</orig><reg>. Ma</reg></choice>
                      combinaison pour<lb/> mon coffre est le numéro 173.<lb/><seg type="signature"
                        rend="centered"><persName ref="#LBrivois">L.B.</persName></seg></lem><note
                      resp="#SDurand">Écrit
              perpendiculairement.</note></app></p></postscript></egXML>
          </exemplum>
          <listRef>
            <ptr target="#TCAPLL"/>
          </listRef>
        </elementSpec>
      </schemaSpec>
    </body>
  </text>
</TEI>
